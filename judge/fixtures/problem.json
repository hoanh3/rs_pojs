[
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "fibonacci_sequence",
            "curators": [],
            "date": "2024-11-22T05:00:00Z",
            "description": "The Fibonacci sequence is a famous number sequence in mathematics, often used in coding challenges. Your task is to generate the first ~N~ numbers of the Fibonacci sequence.\n\n## Input Specification\n\nThe input will contain a single integer ~N~ (~1 \\le N \\le 50~), representing how many terms of the Fibonacci sequence you need to generate.\n\n## Output Specification\n\nOutput ~N~ numbers of the Fibonacci sequence, each separated by a space.\n\n## Sample Input\n\n    5\n\n## Sample Output\n\n    0 1 1 2 3",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Trình tạo dãy Fibonacci",
            "og_image": "",
            "partial": true,
            "points": 10.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [5],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 2
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "sum_of_n_numbers",
            "curators": [],
            "date": "2024-11-22T06:00:00Z",
            "description": "Given an integer ~N~, calculate the sum of all integers from 1 to ~N~.\n\n## Input Specification\n\nA single integer ~N~ (~1 \\le N \\le 10^6~).\n\n## Output Specification\n\nOutput a single integer, the sum from 1 to ~N~.\n\n## Sample Input\n\n    5\n\n## Sample Output\n\n    15",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tổng của N số",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [10],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 3
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "max_of_array",
            "curators": [],
            "date": "2024-11-22T07:00:00Z",
            "description": "Find the maximum value in an array of integers.\n\n## Input Specification\n\nThe first line will contain an integer ~N~ (~1 \\le N \\le 100\\,000~), the number of elements in the array. The next line will contain ~N~ space-separated integers (~-10^9 \\le a_i \\le 10^9~).\n\n## Output Specification\n\nOutput a single integer, the maximum value in the array.\n\n## Sample Input\n\n    5\n    1 2 3 4 5\n\n## Sample Output\n\n    5",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm giá trị lớn nhất trong mảng",
            "og_image": "",
            "partial": true,
            "points": 7.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 4
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "palindrome_checker",
            "curators": [],
            "date": "2024-11-22T08:00:00Z",
            "description": "Check if a given string is a palindrome.\n\n## Input Specification\n\nA single line containing a string ~S~ consisting of lowercase letters only (~1 \\le |S| \\le 1000~).\n\n## Output Specification\n\nOutput ~YES~ if the string is a palindrome, otherwise output ~NO~.\n\n## Sample Input\n\n    racecar\n\n## Sample Output\n\n    YES",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra chuỗi Palindrome",
            "og_image": "",
            "partial": true,
            "points": 6.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [3],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 5
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "binary_search",
            "curators": [],
            "date": "2024-11-22T09:00:00Z",
            "description": "Implement a binary search algorithm to determine if a target value exists in a sorted array.\n\n## Input Specification\n\nThe first line will contain an integer ~N~ (~1 \\le N \\le 100,000~), the number of elements in the array. The next line will contain ~N~ space-separated integers in non-decreasing order. The third line contains an integer ~T~ representing the target value.\n\n## Output Specification\n\nOutput ~YES~ if the target exists in the array, otherwise output ~NO~.\n\n## Sample Input\n\n    5\n    1 3 5 7 9\n    3\n\n## Sample Output\n\n    YES",
            "group": 6,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm kiếm nhị phân",
            "og_image": "",
            "partial": true,
            "points": 8.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [14],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 6
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "linked_list_cycle",
            "curators": [],
            "date": "2024-11-22T10:00:00Z",
            "description": "Detect if a given singly linked list has a cycle.\n\n## Input Specification\n\nYou will be provided with a singly linked list of integers represented as node values. Your task is to determine if there is a cycle in the linked list.\n\n## Output Specification\n\nOutput ~YES~ if there is a cycle, otherwise output ~NO~.\n\n## Sample Input\n\n    List: 1 -> 2 -> 3 -> 4 -> 5 -> 3 (cycle back to 3)\n\n## Sample Output\n\n    YES",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra chu trình trong danh sách liên kết",
            "og_image": "",
            "partial": true,
            "points": 10.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [4],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 7
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "factorial_calculation",
            "curators": [],
            "date": "2024-11-22T11:00:00Z",
            "description": "Calculate the factorial of a given non-negative integer ~N~.\n\n## Input Specification\n\nA single integer ~N~ (~0 \\le N \\le 20~).\n\n## Output Specification\n\nOutput a single integer, the factorial of ~N~.\n\n## Sample Input\n\n    5\n\n## Sample Output\n\n    120",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tính giai thừa",
            "og_image": "",
            "partial": true,
            "points": 7.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [10],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 8
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "gcd_of_two_numbers",
            "curators": [],
            "date": "2024-11-22T12:00:00Z",
            "description": "Find the Greatest Common Divisor (GCD) of two given positive integers.\n\n## Input Specification\n\nTwo space-separated integers ~A~ and ~B~ (~1 \\le A, B \\le 10^6~).\n\n## Output Specification\n\nOutput a single integer, the GCD of ~A~ and ~B~.\n\n## Sample Input\n\n    48 18\n\n## Sample Output\n\n    6",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Ước chung lớn nhất của hai số",
            "og_image": "",
            "partial": true,
            "points": 8.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [5],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 9
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "reverse_string",
            "curators": [],
            "date": "2024-11-22T13:00:00Z",
            "description": "Given a string, reverse the order of characters.\n\n## Input Specification\n\nA single line containing a string ~S~ (~1 \\le |S| \\le 1000~).\n\n## Output Specification\n\nOutput the reversed string.\n\n## Sample Input\n\n    hello\n\n## Sample Output\n\n    olleh",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đảo ngược chuỗi",
            "og_image": "",
            "partial": true,
            "points": 6.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [3],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 10
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "prime_check",
            "curators": [],
            "date": "2024-11-22T14:00:00Z",
            "description": "Determine if a given number is a prime number.\n\n## Input Specification\n\nA single integer ~N~ (~1 \\le N \\le 10^6~).\n\n## Output Specification\n\nOutput ~YES~ if the number is a prime, otherwise output ~NO~.\n\n## Sample Input\n\n    7\n\n## Sample Output\n\n    YES",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra số nguyên tố",
            "og_image": "",
            "partial": true,
            "points": 8.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [10],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 11
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "merge_sorted_arrays",
            "curators": [],
            "date": "2024-11-22T15:00:00Z",
            "description": "Given two sorted arrays, merge them into a single sorted array.\n\n## Input Specification\n\nThe first line will contain an integer ~N~ (~1 \\le N \\le 1000~), the number of elements in the first array. The second line contains ~N~ space-separated integers. The third line will contain an integer ~M~ (~1 \\le M \\le 1000~), the number of elements in the second array. The fourth line contains ~M~ space-separated integers.\n\n## Output Specification\n\nOutput a single line containing the merged sorted array.\n\n## Sample Input\n\n    3\n    1 3 5\n    3\n    2 4 6\n\n## Sample Output\n\n    1 2 3 4 5 6",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Hợp nhất mảng đã sắp xếp",
            "og_image": "",
            "partial": true,
            "points": 9.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 12
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "knapsack_problem1",
            "curators": [],
            "date": "2024-11-22T16:00:00Z",
            "description": "Solve the 0/1 knapsack problem given a set of weights and values.\n\n## Input Specification\n\nThe first line contains two integers ~N~ and ~W~ (~1 \\le N \\le 100, 1 \\le W \\le 1000~), representing the number of items and the maximum weight capacity. Each of the next ~N~ lines contains two integers ~v_i~ and ~w_i~, the value and weight of each item.\n\n## Output Specification\n\nOutput a single integer, the maximum value that can be obtained.\n\n## Sample Input\n\n    3 50\n    60 10\n    100 20\n    120 30\n\n## Sample Output\n\n    220",
            "group": 6,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán Knapsack 0/1",
            "og_image": "",
            "partial": true,
            "points": 15.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [9],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 13
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "valid_parentheses",
            "curators": [],
            "date": "2024-11-22T17:00:00Z",
            "description": "Given a string of parentheses, check if they are balanced.\n\n## Input Specification\n\nA single string ~S~ (~1 \\le |S| \\le 1000~) containing only characters '(', ')', '{', '}', '[' and ']'.\n\n## Output Specification\n\nOutput ~YES~ if the parentheses are balanced, otherwise output ~NO~.\n\n## Sample Input\n\n    ({[]})\n\n## Sample Output\n\n    YES",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra dấu ngoặc hợp lệ",
            "og_image": "",
            "partial": true,
            "points": 8.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [7],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 14
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "breadth_first_search",
            "curators": [],
            "date": "2024-11-22T18:00:00Z",
            "description": "Implement Breadth-First Search (BFS) on a given graph to find the shortest path.\n\n## Input Specification\n\nThe first line will contain two integers ~N~ and ~M~ (~1 \\le N \\le 100, 0 \\le M \\le N^2~), representing the number of nodes and edges. Each of the next ~M~ lines will contain two integers representing an edge between two nodes.\n\n## Output Specification\n\nOutput the shortest path from node 1 to node N.\n\n## Sample Input\n\n    4 4\n    1 2\n    1 3\n    2 4\n    3 4\n\n## Sample Output\n\n    1 -> 2 -> 4",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm kiếm theo chiều rộng (BFS)",
            "og_image": "",
            "partial": true,
            "points": 12.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 15
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "find_peak_element",
            "curators": [],
            "date": "2024-11-22T19:00:00Z",
            "description": "Given an array of integers, find a peak element. A peak element is an element that is strictly greater than its neighbors.\n\n## Input Specification\n\nThe first line will contain an integer ~N~ (~1 \\le N \\le 100,000~), the number of elements in the array. The second line contains ~N~ space-separated integers (~-10^9 \\le a_i \\le 10^9~).\n\n## Output Specification\n\nOutput the index of a peak element. If there are multiple peaks, output any of them.\n\n## Sample Input\n\n    5\n    1 2 3 1 2\n\n## Sample Output\n\n    2",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm phần tử đỉnh",
            "og_image": "",
            "partial": true,
            "points": 8.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 16
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "minimum_coins",
            "curators": [],
            "date": "2024-11-22T20:00:00Z",
            "description": "Given an integer amount, determine the minimum number of coins needed to make up that amount using a given set of coin denominations.\n\n## Input Specification\n\nThe first line will contain an integer ~N~ (~1 \\le N \\le 10,000~), representing the target amount. The second line contains the denominations of coins available, each an integer (~1 \\le coin \\le 100~).\n\n## Output Specification\n\nOutput the minimum number of coins needed to make up the amount. If it's not possible, output ~-1~.\n\n## Sample Input\n\n    11\n    1 5 10\n\n## Sample Output\n\n    2",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán đồng xu tối thiểu",
            "og_image": "",
            "partial": true,
            "points": 12.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [11],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 17
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "merge_intervals",
            "curators": [],
            "date": "2024-11-22T21:00:00Z",
            "description": "Given a collection of intervals, merge all overlapping intervals.\n\n## Input Specification\n\nThe first line will contain an integer ~N~ (~1 \\le N \\le 10^4~), the number of intervals. Each of the next ~N~ lines contains two integers ~start~ and ~end~ (~1 \\le start, end \\le 10^6~), representing the start and end of an interval.\n\n## Output Specification\n\nOutput the merged intervals in any order.\n\n## Sample Input\n\n    4\n    1 3\n    2 6\n    8 10\n    15 18\n\n## Sample Output\n\n    1 6\n    8 10\n    15 18",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Hợp nhất các khoảng thời gian",
            "og_image": "",
            "partial": true,
            "points": 14.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [5],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 18
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "robot_return_to_origin",
            "curators": [],
            "date": "2024-11-22T22:00:00Z",
            "description": "A robot is initially at (0, 0) and can move up, down, left, or right. Given a sequence of moves, determine if the robot returns to the origin.\n\n## Input Specification\n\nA single line containing a string ~S~ (~1 \\le |S| \\le 10^4~), consisting of the characters 'U', 'D', 'L', 'R', which represent Up, Down, Left, and Right moves respectively.\n\n## Output Specification\n\nOutput ~YES~ if the robot returns to the origin, otherwise output ~NO~.\n\n## Sample Input\n\n    UD\n\n## Sample Output\n\n    YES",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Robot quay trở lại điểm gốc",
            "og_image": "",
            "partial": true,
            "points": 10.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [20],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 19
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "number_of_islands",
            "curators": [],
            "date": "2024-11-22T23:00:00Z",
            "description": "Given a 2D grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n\n## Input Specification\n\nThe first line will contain two integers ~N~ and ~M~ (~1 \\le N, M \\le 300~), representing the number of rows and columns in the grid. Each of the next ~N~ lines contains ~M~ characters ('1' or '0').\n\n## Output Specification\n\nOutput a single integer, the number of islands.\n\n## Sample Input\n\n    4 5\n    11000\n    11000\n    00100\n    00011\n\n## Sample Output\n\n    3",
            "group": 6,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đếm số đảo",
            "og_image": "",
            "partial": true,
            "points": 15.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [12],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 20
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "sum_of_digits",
            "curators": [],
            "date": "2024-11-23T00:00:00Z",
            "description": "Given a non-negative integer ~N~, find the sum of its digits.\n\n## Input Specification\n\nA single integer ~N~ (~0 \\le N \\le 10^9~).\n\n## Output Specification\n\nOutput a single integer, the sum of the digits of ~N~.\n\n## Sample Input\n\n    1234\n\n## Sample Output\n\n    10",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tổng các chữ số",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [10],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 21
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "count_set_bits",
            "curators": [],
            "date": "2024-11-23T01:00:00Z",
            "description": "Given an integer ~N~, count the number of set bits (bits with value 1) in its binary representation.\n\n## Input Specification\n\nA single integer ~N~ (~0 \\le N \\le 10^9~).\n\n## Output Specification\n\nOutput the number of set bits in the binary representation of ~N~.\n\n## Sample Input\n\n    5\n\n## Sample Output\n\n    2",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đếm số bit đặt",
            "og_image": "",
            "partial": true,
            "points": 6.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [17],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 22
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maximum_subarray_sum",
            "curators": [],
            "date": "2024-11-23T02:00:00Z",
            "description": "Find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 10^5~), the number of elements in the array. The second line contains ~N~ space-separated integers (~-10^4 \\le a_i \\le 10^4~).\n\n## Output Specification\n\nOutput the maximum sum of the contiguous subarray.\n\n## Sample Input\n\n    9\n    -2 1 -3 4 -1 2 1 -5 4\n\n## Sample Output\n\n    6",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tổng lớn nhất của mảng con",
            "og_image": "",
            "partial": true,
            "points": 10.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [9],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 23
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "palindrome_number",
            "curators": [],
            "date": "2024-11-23T03:00:00Z",
            "description": "Check if a given integer is a palindrome without converting it to a string.\n\n## Input Specification\n\nA single integer ~N~ (~-10^9 \\le N \\le 10^9~).\n\n## Output Specification\n\nOutput ~YES~ if ~N~ is a palindrome, otherwise output ~NO~.\n\n## Sample Input\n\n    121\n\n## Sample Output\n\n    YES",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Số Palindrome",
            "og_image": "",
            "partial": true,
            "points": 8.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [3],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 24
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "longest_common_prefix",
            "curators": [],
            "date": "2024-11-23T04:00:00Z",
            "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 200~), the number of strings. The next ~N~ lines contain a string consisting of lowercase English letters (~1 \\le |S| \\le 200~).\n\n## Output Specification\n\nOutput the longest common prefix of the given strings.\n\n## Sample Input\n\n    3\n    flower\n    flow\n    flight\n\n## Sample Output\n\n    fl",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tiền tố chung dài nhất",
            "og_image": "",
            "partial": true,
            "points": 9.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [3],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 25
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "find_missing_number",
            "curators": [],
            "date": "2024-11-23T05:00:00Z",
            "description": "Given an array containing ~N~ distinct numbers taken from 0, 1, 2, ..., ~N~, find the one that is missing from the array.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 10^5~). The second line contains ~N~ distinct integers ranging from ~0~ to ~N~, but missing one (~0 \\le a_i \\le N~).\n\n## Output Specification\n\nOutput the missing number.\n\n## Sample Input\n\n    3\n    3 0 1\n\n## Sample Output\n\n    2",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm số bị thiếu",
            "og_image": "",
            "partial": true,
            "points": 7.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 26
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "validate_parentheses",
            "curators": [],
            "date": "2024-11-23T06:00:00Z",
            "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. The brackets must close in the correct order.\n\n## Input Specification\n\nA single line containing a string ~S~ (~1 \\le |S| \\le 1000~).\n\n## Output Specification\n\nOutput ~YES~ if the parentheses are valid, otherwise output ~NO~.\n\n## Sample Input\n\n    ()[]{}\n\n## Sample Output\n\n    YES",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra dấu ngoặc hợp lệ",
            "og_image": "",
            "partial": true,
            "points": 8.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [7],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 27
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "rotate_array",
            "curators": [],
            "date": "2024-11-23T07:00:00Z",
            "description": "Given an array, rotate the array to the right by ~k~ steps, where ~k~ is non-negative.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 10^5~), the number of elements in the array. The second line contains ~N~ space-separated integers (~-10^9 \\le a_i \\le 10^9~). The third line contains an integer ~k~ (~0 \\le k \\le 10^5~).\n\n## Output Specification\n\nOutput the rotated array.\n\n## Sample Input\n\n    7\n    1 2 3 4 5 6 7\n    3\n\n## Sample Output\n\n    5 6 7 1 2 3 4",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Xoay mảng",
            "og_image": "",
            "partial": true,
            "points": 10.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 28
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "unique_paths",
            "curators": [],
            "date": "2024-11-23T08:00:00Z",
            "description": "A robot is located at the top-left corner of a ~m x n~ grid. The robot can move either down or right. Find the number of unique paths to reach the bottom-right corner of the grid.\n\n## Input Specification\n\nThe first line contains two integers ~m~ and ~n~ (~1 \\le m, n \\le 100~).\n\n## Output Specification\n\nOutput the number of unique paths.\n\n## Sample Input\n\n    3 2\n\n## Sample Output\n\n    3",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Các đường đi duy nhất",
            "og_image": "",
            "partial": true,
            "points": 12.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [5],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 29
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "jump_game",
            "curators": [],
            "date": "2024-11-23T09:00:00Z",
            "description": "Given an array of non-negative integers, each element represents the maximum number of steps you can take forward. Determine if you can reach the last index.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 10^5~). The second line contains ~N~ space-separated integers (~0 \\le a_i \\le 10^5~).\n\n## Output Specification\n\nOutput ~YES~ if you can reach the last index, otherwise output ~NO~.\n\n## Sample Input\n\n    5\n    2 3 1 1 4\n\n## Sample Output\n\n    YES",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Trò chơi nhảy",
            "og_image": "",
            "partial": true,
            "points": 13.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [9],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 30
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "hamming_distance",
            "curators": [],
            "date": "2024-11-23T10:00:00Z",
            "description": "Given two integers ~x~ and ~y~, calculate the Hamming distance between them.\n\n## Input Specification\n\nTwo integers ~x~ and ~y~ (~0 \\le x, y \\le 10^9~).\n\n## Output Specification\n\nOutput the Hamming distance.\n\n## Sample Input\n\n    1 4\n\n## Sample Output\n\n    2",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Khoảng cách Hamming",
            "og_image": "",
            "partial": true,
            "points": 8.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [17],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 31
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "majority_element",
            "curators": [],
            "date": "2024-11-23T11:00:00Z",
            "description": "Find the majority element in an array of size ~N~. The majority element is the element that appears more than ~N/2~ times.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 10^5~). The second line contains ~N~ space-separated integers (~-10^9 \\le a_i \\le 10^9~).\n\n## Output Specification\n\nOutput the majority element.\n\n## Sample Input\n\n    3\n    3 3 4\n\n## Sample Output\n\n    3",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Phần tử xuất hiện nhiều nhất",
            "og_image": "",
            "partial": true,
            "points": 11.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 32
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "kth_largest_element",
            "curators": [],
            "date": "2024-11-23T12:00:00Z",
            "description": "Find the ~k~th largest element in an array.\n\n## Input Specification\n\nThe first line contains two integers ~N~ and ~k~ (~1 \\le N \\le 10^5, 1 \\le k \\le N~). The second line contains ~N~ space-separated integers (~-10^4 \\le a_i \\le 10^4~).\n\n## Output Specification\n\nOutput the ~k~th largest element.\n\n## Sample Input\n\n    6 2\n    3 2 1 5 6 4\n\n## Sample Output\n\n    5",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Phần tử lớn thứ K",
            "og_image": "",
            "partial": true,
            "points": 13.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [20],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 33
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "product_except_self",
            "curators": [],
            "date": "2024-11-23T13:00:00Z",
            "description": "Given an array of integers ~nums~, return an array ~answer~ such that ~answer[i]~ is equal to the product of all the elements of ~nums~ except ~nums[i]~.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~2 \\le N \\le 10^5~). The second line contains ~N~ space-separated integers (~-30 \\le a_i \\le 30~).\n\n## Output Specification\n\nOutput the product array.\n\n## Sample Input\n\n    4\n    1 2 3 4\n\n## Sample Output\n\n    24 12 8 6",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tích của mảng ngoại trừ chính nó",
            "og_image": "",
            "partial": true,
            "points": 14.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 34
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [
                3,
                4,
                5,
                6,
                2,
                7,
                1,
                8
            ],
            "authors": [
                1
            ],
            "banned_users": [],
            "code": "power_of_three",
            "curators": [],
            "date": "2024-11-23T14:00:00Z",
            "description": "Given an integer ~n~, return ~true~ if it is a power of three. Otherwise, return ~false~.\n\n## Input Specification\n\nA single integer ~n~ (~-2^31 \\le n \\le 2^31 - 1~).\n\n## Output Specification\n\nOutput ~true~ if the integer is a power of three, otherwise ~false~.\n\n## Sample Input\n\n    27\n\n## Sample Output\n\n    true",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Số mũ của 3",
            "og_image": "",
            "partial": true,
            "points": 7.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [
                10
            ],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 35
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [
                3,
                4,
                5,
                6,
                2,
                7,
                1,
                8
            ],
            "authors": [
                1
            ],
            "banned_users": [],
            "code": "climbing_stairs",
            "curators": [],
            "date": "2024-11-23T15:00:00Z",
            "description": "You are climbing a staircase. It takes ~n~ steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n## Input Specification\n\nA single integer ~n~ (~1 \\le n \\le 45~).\n\n## Output Specification\n\nOutput the number of distinct ways to reach the top.\n\n## Sample Input\n\n    3\n\n## Sample Output\n\n    3",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Leo cầu thang",
            "og_image": "",
            "partial": true,
            "points": 9.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [
                5
            ],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 36
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "house_robber",
            "curators": [],
            "date": "2024-11-23T16:00:00Z",
            "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n\n## Input Specification\n\nAn integer array where each element represents the amount of money of each house.\n\n## Output Specification\n\nReturn the maximum amount of money you can rob tonight without alerting the police.",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tên trộm trong nhà",
            "og_image": "",
            "partial": true,
            "points": 10.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [9],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 37
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "valid_palindrome",
            "curators": [],
            "date": "2024-11-23T17:00:00Z",
            "description": "Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n\n## Input Specification\n\nA single string containing only alphanumeric characters and ignoring cases.\n\n## Output Specification\n\nReturn true if the string is a palindrome, false otherwise.",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra Palindrome hợp lệ",
            "og_image": "",
            "partial": true,
            "points": 8.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [3],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 38
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "single_number",
            "curators": [],
            "date": "2024-11-23T18:00:00Z",
            "description": "Given a non-empty array of integers where every element appears twice except for one. Find that single one.\n\n## Input Specification\n\nAn array of integers where every element appears twice except for one.\n\n## Output Specification\n\nReturn the single element that does not appear twice.",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Số duy nhất",
            "og_image": "",
            "partial": true,
            "points": 9.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 39
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "two_sum",
            "curators": [],
            "date": "2024-11-23T19:00:00Z",
            "description": "Given an array of integers ~nums~ and an integer ~target~, find two numbers such that they add up to ~target~.\n\n## Input Specification\n\nAn array of integers ~nums~ and an integer ~target~.\n\n## Output Specification\n\nReturn the indices of the two numbers that add up to ~target~.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Hai số tổng bằng mục tiêu",
            "og_image": "",
            "partial": true,
            "points": 10.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 40
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "remove_duplicates_sorted_array",
            "curators": [],
            "date": "2024-11-23T20:00:00Z",
            "description": "Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.\n\n## Input Specification\n\nA sorted array nums.\n\n## Output Specification\n\nReturn the length of the array after removing the duplicates.",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Xóa các phần tử trùng lặp trong mảng đã sắp xếp",
            "og_image": "",
            "partial": true,
            "points": 8.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 41
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "plus_one",
            "curators": [],
            "date": "2024-11-23T21:00:00Z",
            "description": "Given a non-empty array of decimal digits representing a non-negative integer, increment the integer by one.\n\n## Input Specification\n\nA non-empty array of decimal digits.\n\n## Output Specification\n\nThe array representing the integer after adding one.",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Cộng một",
            "og_image": "",
            "partial": true,
            "points": 7.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 42
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "move_zeroes",
            "curators": [],
            "date": "2024-11-23T22:00:00Z",
            "description": "Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\n## Input Specification\n\nAn array nums containing zeroes and non-zero integers.\n\n## Output Specification\n\nThe array nums with all the zeroes moved to the end, maintaining the relative order of non-zero elements.",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Di chuyển các số không",
            "og_image": "",
            "partial": true,
            "points": 7.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 43
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "reverse_string_1",
            "curators": [],
            "date": "2024-11-23T23:00:00Z",
            "description": "Write a function that reverses a string. The input string is given as an array of characters char[].\n\n## Input Specification\n\nAn array of characters.\n\n## Output Specification\n\nReverse the array of characters in place.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đảo ngược chuỗi",
            "og_image": "",
            "partial": true,
            "points": 6.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 44
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "contains_duplicate",
            "curators": [],
            "date": "2024-11-24T00:00:00Z",
            "description": "Given an array of integers, find if the array contains any duplicates.\n\n## Input Specification\n\nAn array of integers.\n\n## Output Specification\n\nReturn true if any value appears at least twice in the array, and return false if every element is distinct.",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra trùng lặp",
            "og_image": "",
            "partial": true,
            "points": 7.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 45
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "max_product_subarray",
            "curators": [],
            "date": "2024-11-24T01:00:00Z",
            "description": "Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.\n\n## Input Specification\n\nAn array of integers.\n\n## Output Specification\n\nReturn the largest product possible from the subarrays.",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tích lớn nhất của mảng con",
            "og_image": "",
            "partial": true,
            "points": 9.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [9],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 46
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "find_minimum_rotated_sorted_array",
            "curators": [],
            "date": "2024-11-24T02:00:00Z",
            "description": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element.\n\n## Input Specification\n\nA rotated sorted array.\n\n## Output Specification\n\nFind and return the minimum element of the array.",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm giá trị nhỏ nhất trong mảng xoay vòng đã sắp xếp",
            "og_image": "",
            "partial": true,
            "points": 8.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 1.0,
            "types": [1],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 47
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [
                3, 4, 5, 6, 2, 7, 1, 8
            ],
            "authors": [
                1
            ],
            "banned_users": [],
            "code": "basic_math",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Help Alice quickly solve a set of basic arithmetic problems to sharpen her math skills. Each problem consists of adding, subtracting, or multiplying two integers.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 1000~), the number of arithmetic problems. Each of the next ~N~ lines contains a problem in the form of two integers and an operator (+, -, *).\n\n## Output Specification\n\nOutput ~N~ lines, each containing the result of the arithmetic operation.",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Toán học cơ bản",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [
                7
            ],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 48
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [
                3, 4, 5, 6, 2, 7, 1, 8
            ],
            "authors": [
                1
            ],
            "banned_users": [],
            "code": "find_max",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Develop a function to find the maximum number in a list of integers. This will test your ability to iterate over arrays and apply conditional logic.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 10,000~), the number of integers in the list. The next line contains ~N~ space-separated integers.\n\n## Output Specification\n\nOutput a single integer, the largest number in the list.",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm giá trị lớn nhất",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [
                11
            ],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 49
    },
    {
        "model": "judge.problem",
        "pk": 50,
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "challenge50",
            "curators": [],
            "date": "2022-11-23T05:00:00Z",
            "description": "Solve simple multiplication problems.\n\n## Input Specification\n\nThe first line will contain an integer ~N~ (~1 \\le N \\le 1000~), the number of multiplication problems. The next ~N~ lines will each contain two space-separated integers, the two numbers to multiply.\n\n## Output Specification\n\nOutput ~N~ lines of one integer each, the products of the multiplications.",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài tập nhân",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [1],
            "user_count": 0
        }
    },
    {
        "model": "judge.problem",
        "pk": 51,
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "challenge60",
            "curators": [],
            "date": "2022-11-23T05:00:00Z",
            "description": "Find the minimum value in a sequence of numbers.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 1000~), the number of integers. The next line contains ~N~ integers.\n\n## Output Specification\n\nOutput a single integer, the smallest number in the sequence.",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm giá trị nhỏ nhất",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [11],
            "user_count": 0
        }
    },
    {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "addition_sequence",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "Given a sequence of numbers, output the sum of the sequence. The first line contains the number of elements in the sequence, followed by the elements themselves.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 100\\,000~), the number of integers in the sequence. The next line contains ~N~ space-separated integers whose absolute value is less than ~1\\,000\\,000\\,000~.\n\n## Output Specification\n\nOutput a single integer which is the sum of the sequence.\n\n## Sample Input\n\n    4\n    3 5 -2 7\n\n## Sample Output\n\n    13",
          "group": 3,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tổng của chuỗi số",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [5, 9],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 52
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "min_max_finder",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "Tudor needs to find both the minimum and maximum value in a list of numbers. Help him complete this task efficiently.\n\n## Input Specification\n\nThe first line will contain an integer ~N~ (~1 \\le N \\le 100\\,000~), the number of integers in the list. The next line will contain ~N~ space-separated integers whose absolute values are less than ~1\\,000\\,000\\,000~.\n\n## Output Specification\n\nOutput two space-separated integers, the minimum and the maximum values in the list.\n\n## Sample Input\n\n    5\n    -2 4 0 9 -3\n\n## Sample Output\n\n    -3 9",
          "group": 2,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm giá trị lớn nhất và nhỏ nhất",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [3, 15],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 53
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "pairwise_multiplication",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "Tudor is given pairs of numbers and needs to find their products. Help Tudor by calculating the product for each pair.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 100\\,000~), the number of pairs. Each of the next ~N~ lines contains two space-separated integers whose absolute values are less than ~1\\,000\\,000\\,000~.\n\n## Output Specification\n\nOutput ~N~ lines of one integer each, representing the product of the two integers in the pair.\n\n## Sample Input\n\n    3\n    1 2\n    3 4\n    -1 5\n\n## Sample Output\n\n    2\n    12\n    -5",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Nhân từng cặp phần tử",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [7, 11],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 54
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "division_remainder",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "Given two integers, find the quotient and remainder when dividing the first integer by the second.\n\n## Input Specification\n\nThe first line contains an integer ~N~ (~1 \\le N \\le 100\\,000~), the number of divisions to be performed. The next ~N~ lines each contain two space-separated integers, the dividend and the divisor (the divisor will never be zero).\n\n## Output Specification\n\nOutput ~N~ lines of two space-separated integers each, the quotient and remainder respectively.\n\n## Sample Input\n\n    2\n    10 3\n    25 7\n\n## Sample Output\n\n    3 1\n    3 4",
          "group": 5,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Chia và lấy phần dư",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [4, 13],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 55
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "find_absolute",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🔍 Tudor vừa nhận một danh sách các số nguyên và cần tìm giá trị tuyệt đối của từng số. Hãy giúp Tudor hoàn thành nhiệm vụ này một cách nhanh chóng!\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một số nguyên ~N~ (~1 \\le N \\le 100\\,000~), là số lượng số nguyên trong danh sách. Mỗi dòng tiếp theo chứa một số nguyên có giá trị tuyệt đối nhỏ hơn ~1\\,000\\,000\\,000~.\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, mỗi dòng là giá trị tuyệt đối của số đã cho.\n\n## Sample Input\n\n    3\n    -10\n    0\n    5\n\n## Sample Output\n\n    10\n    0\n    5",
          "group": 1,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Máy tính giá trị tuyệt đối",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [2, 17],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 56
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "even_odd_checker",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🔢 Tudor vừa nhận được một loạt các số nguyên và anh ta cần phân loại xem chúng là số chẵn hay lẻ. Hãy giúp anh ta xác định điều này nhé!\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một số nguyên ~N~ (~1 \\le N \\le 100\\,000~), là số lượng số nguyên cần kiểm tra. Mỗi dòng tiếp theo chứa một số nguyên có giá trị tuyệt đối nhỏ hơn ~1\\,000\\,000\\,000~.\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, với mỗi dòng là `even` hoặc `odd` tùy vào số đã cho.\n\n## Sample Input\n\n    4\n    2\n    5\n    7\n    8\n\n## Sample Output\n\n    even\n    odd\n    odd\n    even",
          "group": 1,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Xác định chẵn hoặc lẻ",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [1, 10],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 57
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "factorial_finder",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🧮 Tudor đang gặp khó khăn trong việc tính giai thừa của một số nhỏ. Hãy giúp anh ta tính toán các giai thừa này một cách chính xác!\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một số nguyên ~N~ (~1 \\le N \\le 10~), là số lượng truy vấn. Mỗi dòng tiếp theo chứa một số nguyên ~K~ (~1 \\le K \\le 20~).\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, mỗi dòng là giá trị giai thừa của số đã cho.\n\n## Sample Input\n\n    3\n    5\n    3\n    6\n\n## Sample Output\n\n    120\n    6\n    720",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Máy tính giai thừa",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [12, 18],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 58
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "gcd_finder",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🔗 Tudor muốn tìm Ước số chung lớn nhất (GCD) của các cặp số đã cho. Hãy giúp anh ta xác định GCD của mỗi cặp số nhé.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một số nguyên ~N~ (~1 \\le N \\le 100\\,000~), là số lượng cặp số. Mỗi dòng tiếp theo chứa hai số nguyên cách nhau bởi khoảng trắng, có giá trị tuyệt đối nhỏ hơn ~1\\,000\\,000\\,000~.\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, mỗi dòng là một số nguyên đại diện cho GCD của cặp số đã cho.\n\n## Sample Input\n\n    2\n    12 15\n    100 25\n\n## Sample Output\n\n    3\n    25",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm ước chung lớn nhất",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [6, 14],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 59
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "fibonacci_finder",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🔢 Tudor đang muốn biết số Fibonacci tại một vị trí cụ thể. Hãy giúp Tudor tìm ra số Fibonacci cho từng vị trí đã cho.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một số nguyên ~N~ (~1 \\le N \\le 10~), là số lượng truy vấn. Mỗi dòng tiếp theo chứa một số nguyên ~K~ (~1 \\le K \\le 30~), đại diện cho vị trí trong dãy Fibonacci.\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, mỗi dòng là số Fibonacci tại vị trí đã cho.\n\n## Sample Input\n\n    3\n    5\n    10\n    15\n\n## Sample Output\n\n    5\n    55\n    610",
          "group": 5,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm dãy Fibonacci",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [8, 19],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 60
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "prime_checker",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🔍 Tudor muốn xác định xem một số có phải là số nguyên tố hay không. Hãy giúp anh ấy kiểm tra nhanh chóng nhé!\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một số nguyên ~N~ (~1 \\le N \\le 100\\,000~), là số lượng số cần kiểm tra. Mỗi dòng tiếp theo chứa một số nguyên ~K~ (~1 \\le K \\le 1\\,000\\,000\\,000~).\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, mỗi dòng là `prime` nếu số đó là nguyên tố, hoặc `not prime` nếu không phải.\n\n## Sample Input\n\n    3\n    7\n    4\n    11\n\n## Sample Output\n\n    prime\n    not prime\n    prime",
          "group": 3,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Kiểm tra số nguyên tố",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [7, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 61
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "sum_of_digits1",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "➕ Tudor vừa nhận được một danh sách các số và cần tính tổng các chữ số của mỗi số đó. Hãy giúp anh ta nhé!\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một số nguyên ~N~ (~1 \\le N \\le 100\\,000~), là số lượng số. Mỗi dòng tiếp theo chứa một số nguyên không âm ~K~ (~0 \\le K \\le 1\\,000\\,000\\,000~).\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, mỗi dòng là tổng của các chữ số của số đó.\n\n## Sample Input\n\n    3\n    123\n    456\n    789\n\n## Sample Output\n\n    6\n    15\n    24",
          "group": 2,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Máy tính tổng các chữ số",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [3, 8],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 62
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "reverse_number",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🔄 Tudor muốn đảo ngược một số nguyên dương. Hãy giúp anh ấy bằng cách cung cấp giá trị đảo ngược của mỗi số.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một số nguyên ~N~ (~1 \\le N \\le 100\\,000~), là số lượng số. Mỗi dòng tiếp theo chứa một số nguyên dương ~K~ (~1 \\le K \\le 1\\,000\\,000\\,000~).\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, mỗi dòng là số đã được đảo ngược.\n\n## Sample Input\n\n    3\n    123\n    400\n    789\n\n## Sample Output\n\n    321\n    4\n    987",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Máy tính đảo ngược số",
            "og_image": "",
          "partial": true,
          "points": 5.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [9, 14],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 63
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "lcm_finder",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🌟 Tudor muốn tìm Bội số chung nhỏ nhất (LCM) của các cặp số. Hãy giúp Tudor bằng cách tìm LCM cho mỗi cặp.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một số nguyên ~N~ (~1 \\le N \\le 100\\,000~), là số lượng cặp số. Mỗi dòng tiếp theo chứa hai số nguyên dương ~A~ và ~B~ (~1 \\le A, B \\le 1\\,000\\,000\\,000~).\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, mỗi dòng là LCM của cặp số đã cho.\n\n## Sample Input\n\n    2\n    4 6\n    15 25\n\n## Sample Output\n\n    12\n    75",
          "group": 5,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm bội chung nhỏ nhất",
            "og_image": "",
          "partial": true,
          "points": 10.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 3.0,
          "types": [4, 13],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 64
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "matrix_multiplication",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🧮 Tudor cần thực hiện phép nhân hai ma trận vuông kích thước ~N \\times N~. Hãy giúp Tudor thực hiện phép tính này một cách chính xác.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một số nguyên ~N~ (~1 \\le N \\le 500~), là kích thước của các ma trận. Tiếp theo là ~N~ dòng, mỗi dòng chứa ~N~ số nguyên đại diện cho ma trận đầu tiên. Sau đó là ~N~ dòng khác, mỗi dòng chứa ~N~ số nguyên đại diện cho ma trận thứ hai (~-1\\,000 \\le a_{ij} \\le 1\\,000~).\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, mỗi dòng chứa ~N~ số nguyên là kết quả của phép nhân ma trận.\n\n## Sample Input\n\n    2\n    1 2\n    3 4\n    5 6\n    7 8\n\n## Sample Output\n\n    19 22\n    43 50",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 131072,
          "name": "Nhân ma trận",
            "og_image": "",
          "partial": true,
          "points": 15.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 4.0,
          "types": [14, 20],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 65
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "shortest_path",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🌐 Tudor muốn tìm đường đi ngắn nhất từ một điểm đến một điểm khác trong một đồ thị có trọng số. Hãy giúp Tudor thực hiện bài toán này.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa hai số nguyên ~N~ và ~M~ (~1 \\le N \\le 1,000~, ~1 \\le M \\le 10,000~), là số lượng đỉnh và số lượng cạnh của đồ thị. Tiếp theo là ~M~ dòng, mỗi dòng chứa ba số nguyên ~u~, ~v~, và ~w~ (~1 \\le u, v \\le N~, ~1 \\le w \\le 1,000~), đại diện cho cạnh từ đỉnh ~u~ đến đỉnh ~v~ có trọng số ~w~. Đỉnh bắt đầu là ~1~, đỉnh kết thúc là ~N~.\n\n## Output Specification\n\n✏️ Xuất ra một số nguyên, là độ dài của đường đi ngắn nhất từ đỉnh ~1~ đến đỉnh ~N~. Nếu không có đường đi, xuất `-1`.\n\n## Sample Input\n\n    5 6\n    1 2 2\n    1 3 4\n    2 3 1\n    2 4 7\n    3 5 3\n    4 5 1\n\n## Sample Output\n\n    8",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 131072,
          "name": "Tìm đường đi ngắn nhất",
            "og_image": "",
          "partial": true,
          "points": 20.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 3.0,
          "types": [15, 21],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 66
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "knapsack_problem",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🎒 Tudor đang có một chiếc ba lô với sức chứa giới hạn và muốn chọn các vật phẩm sao cho tổng giá trị là lớn nhất. Hãy giúp Tudor tối ưu hóa việc chọn lựa các vật phẩm.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa hai số nguyên ~N~ và ~W~ (~1 \\le N \\le 1,000~, ~1 \\le W \\le 10,000~), là số lượng vật phẩm và sức chứa tối đa của ba lô. Tiếp theo là ~N~ dòng, mỗi dòng chứa hai số nguyên ~w_i~ và ~v_i~ (~1 \\le w_i, v_i \\le 1,000~), là trọng lượng và giá trị của vật phẩm thứ ~i~.\n\n## Output Specification\n\n✏️ Xuất ra một số nguyên, là tổng giá trị lớn nhất có thể đạt được khi chọn các vật phẩm để không vượt quá sức chứa của ba lô.\n\n## Sample Input\n\n    4 7\n    1 1\n    3 4\n    4 5\n    5 7\n\n## Sample Output\n\n    9",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 131072,
          "name": "Tối ưu hóa giá trị",
            "og_image": "",
          "partial": true,
          "points": 25.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 3.0,
          "types": [16, 18],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 67
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "max_flow",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🚰 Tudor đang tìm cách tính toán dòng chảy lớn nhất có thể từ nguồn đến đích trong một mạng lưới. Hãy giúp Tudor tìm ra giá trị dòng chảy lớn nhất.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa hai số nguyên ~N~ và ~M~ (~2 \\le N \\le 500~, ~1 \\le M \\le 5,000~), là số lượng đỉnh và số lượng cạnh của mạng lưới. Tiếp theo là ~M~ dòng, mỗi dòng chứa ba số nguyên ~u~, ~v~, và ~c~ (~1 \\le u, v \\le N~, ~1 \\le c \\le 1,000~), đại diện cho cạnh từ đỉnh ~u~ đến đỉnh ~v~ có dung lượng ~c~. Đỉnh ~1~ là nguồn và đỉnh ~N~ là đích.\n\n## Output Specification\n\n✏️ Xuất ra một số nguyên, là giá trị dòng chảy lớn nhất từ đỉnh ~1~ đến đỉnh ~N~.\n\n## Sample Input\n\n    4 5\n    1 2 40\n    1 3 20\n    2 3 10\n    2 4 30\n    3 4 20\n\n## Sample Output\n\n    50",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 131072,
          "name": "Tính toán dòng chảy tối đa",
            "og_image": "",
          "partial": true,
          "points": 30.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 4.0,
          "types": [17, 21],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 68
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "segment_tree",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🌳 Tudor cần quản lý một dãy số và thực hiện các phép tính truy vấn như tính tổng hoặc tìm giá trị lớn nhất trong một đoạn bất kỳ. Hãy giúp Tudor bằng cách sử dụng cây đoạn (segment tree).\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa hai số nguyên ~N~ và ~Q~ (~1 \\le N, Q \\le 100,000~), là số lượng phần tử trong dãy và số lượng truy vấn. Dòng tiếp theo chứa ~N~ số nguyên là các phần tử của dãy (~1 \\le a_i \\le 1,000~). Mỗi trong ~Q~ dòng tiếp theo có dạng `1 L R` hoặc `2 L R` để yêu cầu tính tổng hoặc tìm giá trị lớn nhất từ chỉ số ~L~ đến ~R~.\n\n## Output Specification\n\n✏️ Xuất ra ~Q~ dòng, mỗi dòng là kết quả của truy vấn tương ứng.\n\n## Sample Input\n\n    5 3\n    1 3 5 7 9\n    1 1 3\n    2 2 4\n    1 3 5\n\n## Sample Output\n\n    9\n    7\n    21",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 131072,
          "name": "Các thao tác trên cây đoạn (segment tree)",
            "og_image": "",
          "partial": true,
          "points": 35.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [18, 20],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 69
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "graph_coloring",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🎨 Tudor cần tô màu các đỉnh của một đồ thị sao cho không có hai đỉnh kề nhau có cùng màu và số lượng màu được sử dụng là ít nhất. Hãy giúp Tudor thực hiện việc tô màu này.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa hai số nguyên ~N~ và ~M~ (~1 \\le N \\le 500~, ~0 \\le M \\le 10,000~), là số lượng đỉnh và số lượng cạnh của đồ thị. Tiếp theo là ~M~ dòng, mỗi dòng chứa hai số nguyên ~u~ và ~v~ (~1 \\le u, v \\le N~), đại diện cho cạnh giữa hai đỉnh ~u~ và ~v~.\n\n## Output Specification\n\n✏️ Xuất ra một số nguyên, là số lượng màu ít nhất cần thiết để tô màu các đỉnh của đồ thị.\n\n## Sample Input\n\n    5 5\n    1 2\n    1 3\n    2 4\n    3 5\n    4 5\n\n## Sample Output\n\n    3",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 131072,
          "name": "Bài toán tô màu đồ thị",
            "og_image": "",
          "partial": true,
          "points": 40.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [19, 21],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 70
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "prime_factors",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🔍 Tudor muốn tìm tất cả các ước số nguyên tố của một số nguyên lớn. Hãy giúp Tudor xác định các ước số nguyên tố này.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một số nguyên ~N~ (~1 \\le N \\le 100,000~), là số lượng số cần tìm ước. Mỗi dòng tiếp theo chứa một số nguyên ~K~ (~1 \\le K \\le 1,000,000,000~).\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, mỗi dòng chứa danh sách các ước số nguyên tố của ~K~, theo thứ tự tăng dần, phân tách bởi khoảng trắng.\n\n## Sample Input\n\n    3\n    12\n    15\n    7\n\n## Sample Output\n\n    2 3\n    3 5\n    7",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm các thừa số nguyên tố",
            "og_image": "",
          "partial": true,
          "points": 15.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 3.0,
          "types": [9, 17],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 71
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "interval_sum_queries",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "📊 Tudor đang có một mảng và cần phải xử lý các truy vấn tính tổng trên một đoạn. Hãy giúp Tudor trả lời các truy vấn này nhanh nhất có thể.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa hai số nguyên ~N~ và ~Q~ (~1 \\le N, Q \\le 100,000~), là số lượng phần tử trong mảng và số lượng truy vấn. Dòng thứ hai chứa ~N~ số nguyên là các phần tử của mảng (~-1,000 \\le a_i \\le 1,000~). Mỗi trong ~Q~ dòng tiếp theo chứa hai số nguyên ~L~ và ~R~ (~1 \\le L, R \\le N~), đại diện cho truy vấn tính tổng từ vị trí ~L~ đến ~R~.\n\n## Output Specification\n\n✏️ Xuất ra ~Q~ dòng, mỗi dòng là kết quả của truy vấn tương ứng.\n\n## Sample Input\n\n    5 3\n    1 2 3 4 5\n    1 3\n    2 4\n    1 5\n\n## Sample Output\n\n    6\n    9\n    15",
          "group": 5,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Truy vấn tổng các khoảng",
            "og_image": "",
          "partial": true,
          "points": 20.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [11, 18],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 72
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "binary_search_algorithm",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🔍 Tudor muốn tìm kiếm một phần tử trong một mảng đã được sắp xếp. Hãy giúp Tudor sử dụng thuật toán tìm kiếm nhị phân để trả lời các truy vấn tìm kiếm.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa hai số nguyên ~N~ và ~Q~ (~1 \\le N, Q \\le 100,000~), là số lượng phần tử trong mảng và số lượng truy vấn. Dòng thứ hai chứa ~N~ số nguyên là các phần tử của mảng đã được sắp xếp theo thứ tự tăng dần (~-1,000,000 \\le a_i \\le 1,000,000~). Mỗi trong ~Q~ dòng tiếp theo chứa một số nguyên ~X~, đại diện cho giá trị cần tìm kiếm.\n\n## Output Specification\n\n✏️ Xuất ra ~Q~ dòng, với mỗi dòng là chỉ số của phần tử tìm thấy (bắt đầu từ 1) hoặc `-1` nếu không tìm thấy.\n\n## Sample Input\n\n    5 3\n    1 3 5 7 9\n    3\n    6\n    9\n\n## Sample Output\n\n    2\n    -1\n    5",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Thuật toán tìm kiếm nhị phân",
            "og_image": "",
          "partial": true,
          "points": 15.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 2.0,
          "types": [10, 17],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 73
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "dijkstra_shortest_path",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🛣️ Tudor muốn tìm đường đi ngắn nhất từ một điểm đến tất cả các điểm khác trong một đồ thị có trọng số. Hãy giúp Tudor sử dụng thuật toán Dijkstra để tìm đường đi ngắn nhất.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa hai số nguyên ~N~ và ~M~ (~1 \\le N \\le 1,000~, ~1 \\le M \\le 10,000~), là số lượng đỉnh và số lượng cạnh của đồ thị. Tiếp theo là ~M~ dòng, mỗi dòng chứa ba số nguyên ~u~, ~v~, và ~w~ (~1 \\le u, v \\le N~, ~1 \\le w \\le 1,000~), đại diện cho cạnh từ đỉnh ~u~ đến đỉnh ~v~ có trọng số ~w~.\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, với mỗi dòng là khoảng cách ngắn nhất từ đỉnh ~1~ đến đỉnh tương ứng. Nếu không có đường đi, xuất `-1`.\n\n## Sample Input\n\n    5 6\n    1 2 2\n    1 3 4\n    2 3 1\n    2 4 7\n    3 5 3\n    4 5 1\n\n## Sample Output\n\n    0\n    2\n    3\n    9\n    6",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 131072,
          "name": "Thuật toán đường đi ngắn nhất Dijkstra",
            "og_image": "",
          "partial": true,
          "points": 25.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 4.0,
          "types": [15, 21],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 74
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "connected_components",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🔗 Tudor muốn tìm tất cả các thành phần liên thông trong một đồ thị vô hướng. Hãy giúp Tudor xác định số lượng các thành phần liên thông.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa hai số nguyên ~N~ và ~M~ (~1 \\le N \\le 100,000~, ~0 \\le M \\le 200,000~), là số lượng đỉnh và số lượng cạnh của đồ thị. Tiếp theo là ~M~ dòng, mỗi dòng chứa hai số nguyên ~u~ và ~v~ (~1 \\le u, v \\le N~), đại diện cho cạnh giữa hai đỉnh ~u~ và ~v~.\n\n## Output Specification\n\n✏️ Xuất ra một số nguyên, là số lượng thành phần liên thông trong đồ thị.\n\n## Sample Input\n\n    6 3\n    1 2\n    2 3\n    4 5\n\n## Sample Output\n\n    3",
          "group": 5,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 131072,
          "name": "Tìm các thành phần liên thông",
            "og_image": "",
          "partial": true,
          "points": 20.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 3.0,
          "types": [13, 19],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 75
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "strongly_connected_components",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "🔗 Tudor muốn tìm tất cả các thành phần liên thông mạnh trong một đồ thị có hướng. Hãy giúp Tudor xác định các thành phần liên thông mạnh này.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa hai số nguyên ~N~ và ~M~ (~1 \\le N \\le 100,000~, ~0 \\le M \\le 200,000~), là số lượng đỉnh và số lượng cạnh của đồ thị. Tiếp theo là ~M~ dòng, mỗi dòng chứa hai số nguyên ~u~ và ~v~ (~1 \\le u, v \\le N~), đại diện cho cạnh từ đỉnh ~u~ đến đỉnh ~v~.\n\n## Output Specification\n\n✏️ Xuất ra một số nguyên, là số lượng thành phần liên thông mạnh trong đồ thị.\n\n## Sample Input\n\n    5 5\n    1 2\n    2 3\n    3 1\n    4 5\n    5 4\n\n## Sample Output\n\n    2",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 131072,
          "name": "Các thành phần liên thông mạnh",
            "og_image": "",
          "partial": true,
          "points": 30.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 4.0,
          "types": [19, 21],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 76
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "suffix_array",
          "curators": [],
          "date": "2017-12-02T05:00:00Z",
          "description": "📚 Tudor muốn xây dựng một mảng hậu tố cho một chuỗi ký tự. Hãy giúp Tudor xây dựng mảng hậu tố và sắp xếp chúng theo thứ tự từ điển.\n\n## Input Specification\n\n📄 Dòng đầu tiên chứa một chuỗi ký tự ~S~ có độ dài từ ~1~ đến ~100,000~, chỉ bao gồm các chữ cái thường tiếng Anh.\n\n## Output Specification\n\n✏️ Xuất ra ~N~ dòng, mỗi dòng là vị trí bắt đầu của một hậu tố trong chuỗi, theo thứ tự từ điển.\n\n## Sample Input\n\n    banana\n\n## Sample Output\n\n    5\n    3\n    1\n    0\n    4\n    2",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 131072,
          "name": "Xây dựng mảng hậu tố (suffix array)",
            "og_image": "",
          "partial": true,
          "points": 30.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 3.0,
          "types": [14, 20],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 77
      },
      {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "simplemath1",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Alice đang học toán cơ bản và cần tìm số lớn nhất trong một danh sách. Hãy giúp Alice hoàn thành bài tập này!",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm giá trị lớn nhất",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [1, 5, 10],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 78
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "sumofnumbers2",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Bob được giao bài tập tính tổng của một danh sách số nguyên dương. Bạn có thể hỗ trợ Bob không?",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tổng các số dương",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [2, 8, 15],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 79
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "multiplicationtask3",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Charlie cần nhân hai số nguyên lớn. Hãy tính toán và đưa ra kết quả chính xác!",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Thử thách nhân",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [3, 9, 18],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 80
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "evenoddcheck4",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Diana muốn kiểm tra xem một số nguyên là số chẵn hay lẻ. Hãy giúp cô ấy!",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Chẵn hoặc lẻ",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [6, 11, 14],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 81
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "primecheck5",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Evelyn đang học về số nguyên tố. Hãy kiểm tra xem số được đưa vào có phải số nguyên tố hay không.",
            "group": 6,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra số nguyên tố",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [4, 13, 20],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 82
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "arrayreversal6",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Frank muốn đảo ngược một mảng số nguyên. Hãy giúp anh ấy thực hiện yêu cầu này.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đảo ngược mảng",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [7, 12, 19],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 83
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "stringcompare7",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Grace có hai chuỗi ký tự và muốn kiểm tra xem chúng có giống nhau hay không. Bạn có thể hỗ trợ cô ấy?",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "So sánh chuỗi",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [9, 14, 21],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 84
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "binarysum8",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Hank đang học hệ nhị phân và muốn cộng hai số nhị phân. Hãy đưa ra kết quả chính xác!",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tổng nhị phân",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [3, 16, 18],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 85
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "primecheck6",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Evelyn đang học về số nguyên tố. Hãy kiểm tra xem số được đưa vào có phải số nguyên tố hay không!",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra số nguyên tố",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [4, 7, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 86
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "gcdfind7",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Michael cần tính ước chung lớn nhất (GCD) của hai số nguyên. Hãy giúp Michael giải quyết bài toán này!",
            "group": 6,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Ước chung lớn nhất (GCD)",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [5, 6, 12],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 87
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "divisibilitytask8",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Sophia muốn kiểm tra tính chia hết của một số cho một số nguyên khác. Cô ấy cần giúp đỡ!",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra tính chia hết",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [1, 6, 13],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 88
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "sumsequence9",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Oliver được yêu cầu tính tổng của một dãy số từ 1 đến N. Hãy giúp Oliver giải quyết bài toán này!",
            "group": 2,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tổng của chuỗi số",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [3, 7, 17],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 89
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "factorialcal10",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Noah đang học về giai thừa và cần tính giai thừa của một số nguyên. Hãy giúp Noah tính toán!",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tính giai thừa",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [4, 8, 14],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 90
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "binarysearch11",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Liam đang học về thuật toán tìm kiếm nhị phân. Hãy giúp anh ta tìm phần tử trong một dãy đã được sắp xếp!",
            "group": 1,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm kiếm nhị phân",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [2, 9, 12],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 91
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "matrixmultiply12",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Ethan cần nhân hai ma trận với nhau. Hãy giúp Ethan hoàn thành bài toán này!",
            "group": 6,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Nhân ma trận",
            "og_image": "",
            "partial": true,
            "points": 5.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 2.0,
            "types": [6, 10, 13],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 92
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "longestpath93",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Trong bài toán này, bạn sẽ được cho một đồ thị có n đỉnh và m cạnh. Hãy tìm chiều dài của đường đi dài nhất từ đỉnh 1 đến đỉnh n, với yêu cầu tối ưu hóa thời gian tính toán.",
            "group": 6,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đường đi dài nhất trong đồ thị",
            "og_image": "",
            "partial": true,
            "points": 10.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 3.0,
            "types": [4, 6, 19],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 93
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "knapsackproblem94",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Bài toán này yêu cầu bạn giải quyết vấn đề Knapsack với các món đồ có trọng lượng và giá trị khác nhau. Hãy tìm cách tối ưu hóa việc chọn đồ sao cho tổng giá trị là lớn nhất nhưng tổng trọng lượng không vượt quá một giá trị cố định.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán ba lô",
            "og_image": "",
            "partial": true,
            "points": 10.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 4.0,
            "types": [1, 12, 21],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 94
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "stringedit95",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Bài toán yêu cầu bạn áp dụng thuật toán chuỗi để tìm số bước tối thiểu cần thiết để chuyển đổi một chuỗi s1 thành chuỗi s2, với phép biến đổi chỉ được phép là chèn, xóa, hoặc thay thế một ký tự tại một vị trí cụ thể.",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Khoảng cách chỉnh sửa chuỗi",
            "og_image": "",
            "partial": true,
            "points": 10.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 3.0,
            "types": [2, 6, 13],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 95
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "tsp96",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Bài toán này yêu cầu bạn giải quyết bài toán TSP (Traveling Salesman Problem) với một bộ các thành phố. Hãy tìm cách tối ưu hóa quãng đường di chuyển sao cho tổng quãng đường đi qua tất cả các thành phố là ngắn nhất.",
            "group": 6,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán TSP",
            "og_image": "",
            "partial": true,
            "points": 15.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 4.0,
            "types": [3, 10, 18],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 96
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "graphmatching97",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Trong bài toán này, bạn sẽ được cho hai đồ thị và yêu cầu tìm cách ghép nối các đỉnh sao cho tổng trọng số các cạnh là lớn nhất, điều này đòi hỏi thuật toán tìm kiếm và tối ưu hóa đồ thị phức tạp.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán ghép đồ thị",
            "og_image": "",
            "partial": true,
            "points": 15.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 4.0,
            "types": [1, 5, 21],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 97
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "binarysearchtree98",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Bài toán này yêu cầu bạn xây dựng một cây nhị phân tìm kiếm (Binary Search Tree - BST) và thực hiện các phép toán cơ bản như tìm kiếm, chèn và xóa phần tử. Bài toán sẽ cho bạn một dãy các phép toán (chèn, tìm kiếm, xóa) trên một cây nhị phân, và bạn cần xử lý các thao tác này sao cho kết quả cuối cùng là chính xác. Cây nhị phân phải được duy trì trong trạng thái cân bằng sau mỗi phép toán để tối ưu hóa độ phức tạp.",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Các thao tác trên cây tìm kiếm nhị phân",
            "og_image": "",
            "partial": true,
            "points": 15.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [1, 11, 15],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 98
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maxflow99",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Bài toán yêu cầu bạn giải quyết bài toán luồng tối đa (Maximum Flow) trong một mạng lưới đồ thị có trọng số. Được cho một đồ thị với các đỉnh và các cạnh có trọng số, bạn cần xác định dòng chảy tối đa từ một nguồn đến một đích trong đồ thị. Bài toán yêu cầu bạn áp dụng thuật toán như Edmonds-Karp hoặc Ford-Fulkerson để tính toán dòng chảy tối đa và tối ưu hóa giải thuật sao cho đạt được hiệu quả tính toán tốt nhất.",
            "group": 6,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán dòng chảy tối đa",
            "og_image": "",
            "partial": true,
            "points": 20.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 6.0,
            "types": [3, 7, 20],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 99
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "graphcoloring100",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Bài toán này yêu cầu bạn giải quyết bài toán tô màu đồ thị (Graph Coloring), trong đó bạn cần tô màu các đỉnh của một đồ thị sao cho không có hai đỉnh nào kề nhau có cùng màu. Bạn sẽ được cho một đồ thị vô hướng và phải tìm cách phân bổ màu sao cho số màu sử dụng là tối thiểu, đồng thời đáp ứng điều kiện trên. Đây là một bài toán NP-Hard, do đó cần áp dụng các thuật toán tối ưu để giải quyết với các đồ thị có số lượng đỉnh và cạnh lớn.",
            "group": 6,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán đỉnh đồ thị kề nhau",
            "og_image": "",
            "partial": true,
            "points": 25.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 6.0,
            "types": [4, 10, 19],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 100
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "huffman101",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Bài toán này yêu cầu bạn giải quyết bài toán mã hóa Huffman. Bạn được cho một dãy các ký tự và tần suất xuất hiện của từng ký tự. Mục tiêu của bài toán là xây dựng một mã Huffman tối ưu cho dãy ký tự, sao cho tổng chiều dài của mã là nhỏ nhất. Thuật toán Huffman là một thuật toán tối ưu giúp giảm thiểu độ dài mã của các ký tự trong một dãy, được áp dụng phổ biến trong các bài toán nén dữ liệu.",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Mã hóa Huffman",
            "og_image": "",
            "partial": true,
            "points": 30.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [1, 5, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 101
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "gift101",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Hôm nay là sinh nhật của Cá Nóc. Vì biết Cá Nóc rất thích chơi với những con số nên một người bạn tri kỉ của cậu ấy - Thợ Săn đã tặng cho Cá Nóc hộp quà đặc biệt. Nhưng tất cả hộp quà đều bị khóa và đi kèm với mỗi hộp là một số nguyên dương. Thợ săn còn tặng cho Cá Nóc một công thức như sau: Thợ Săn nói với Cá Nóc rằng: với số đi kèm trong mỗi hộp quà, hãy biến đổi thành một số lần cho tới khi. Số lần thực hiện phép biến đổi chính là mã số để mở khóa hộp quà đó.\n\n## Input Specification\n\nThe first line will contain an integer ~N~ (~1 \\le N \\le 100\\,000~), the number of addition problems Tudor needs to do. The next ~N~ lines will each contain two space-separated integers whose absolute value is less than ~1\\,000\\,000\\,000~, the two integers Tudor needs to add.\n\n## Output Specification\n\nOutput ~N~ lines of one integer each, the solutions to the addition problems in order.\n\n## Sample Input\n\n    2\n    1 1\n    -1 0\n\n## Sample Output\n\n    2\n    -1",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "GIFT - Hộp quà đặc biệt",
            "og_image": "",
            "partial": true,
            "points": 30.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [2, 6, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 102
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "equa2",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Cơ quan cảnh sát quốc gia Nhật Bản (National Police Agency hay còn gọi là NPA) là cơ quan trung ương của Hệ thống cảnh sát Nhật Bản, và là cơ quan điều phối trung ương về thực thi pháp luật trong các tình huống khẩn cấp quốc gia ở Nhật Bản. Nghe đến cái tên thôi cũng đã thấy nó rất cool ngầu rồi. Chính vì thế anh Hiếu có dự định sang Nhật và trở thành một sĩ quan cấp siêu cao của NPA. Để đánh giá năng lực của anh Hiếu họ đã đưa ra một bài toán rất khó: Giải phương trình nghiệm nguyên dương.\n\n## Sample Input\n\n    2\n    1 1\n    -1 0\n\n## Sample Output\n\n    2\n    -1",
            "group": 3,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Giải phương trình nghiệm nguyên dương",
            "og_image": "",
            "partial": true,
            "points": 30.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [4, 8],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 103
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "covid19",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Dịch Covid_19 với cơ chế lây lan như sau: Ban đầu có 1 người nhiễm, sau 1 ngày sẽ lây lan cho K người. Hỏi sau N ngày thì số lượng người bị lây nhiễm sẽ là bao nhiêu. Biết rằng sau khi lây cho người khác thì người này bị đem đi cách ly. Vì kết quả bài toán có thể rất lớn nên kết quả chỉ lấy số dư với 2021. Nhưng nếu mà ngày 1 mà đc tổng cộng là 1 người thì người đó sẽ đem đi chữa trị và hồi phục. Còn nếu như số ngày không lên tới 1 thì số người vẫn là 1.\n\n## Sample Input\n\n    2\n    1 1\n    -1 0\n\n## Sample Output\n\n    2\n    -1",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "COVID19 - Số người nhiễm Covid-19",
            "og_image": "",
            "partial": true,
            "points": 30.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [6, 11],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 104
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "loj102",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Cho một đồ thị trong đó mỗi cạnh có dung lượng và chi phí, một mức phí cụ thể phải trả cho việc sử dụng một đơn vị lưu lượng trên mỗi cạnh. Biết đỉnh bắt đầu là và đỉnh kết thúc là , hãy tìm luồng cực đại của đồ thị (dung lượng) và mức phí tối thiểu phải trả cho luồng cực đại đó.\n\n## Sample Input\n\n    2\n    1 1\n    -1 0\n\n## Sample Output\n\n    2\n    -1",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "LOJ102 - Luồng cực đại với chi phí nhỏ nhất",
            "og_image": "",
            "partial": true,
            "points": 30.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [4, 18],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 105
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "notri",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Cho tam giác. Trên cạnh lấy điểm khác nhau (không trùng với và ). Nối với các điểm đó. Hãy xác định xem ta có thể đếm được bao nhiêu hình tam giác.\n\n## Sample Input\n\n    2\n    1 1\n    -1 0\n\n## Sample Output\n\n    2\n    -1",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "NOFTRI - Số lượng tam giác",
            "og_image": "",
            "partial": true,
            "points": 30.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [8, 17],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 106
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "skgp",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Có một ngọn núi hình nón, nếu bạn xây dựng một đường đi ngắn nhất cho một chuyến tàu tham quan. Đường ray bắt đầu tại điểm và kết thúc tại điểm , đoạn đường đầu tiên là lên dốc, nhưng đoạn tiếp theo sẽ xuống dốc. Vấn đề đặt ra như sau: Cho trước số nguyên dương , hãy cho biết chiều dài của đoạn đường xuống dốc là bao nhiêu?\n\n## Sample Input\n\n    2\n    1 1\n    -1 0\n\n## Sample Output\n\n    2\n    -1",
            "group": 5,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "SKGP - Chiều dài của đoạn xuống dốc",
            "og_image": "",
            "partial": true,
            "points": 30.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [8, 17],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 107
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "vnpn",
            "curators": [],
            "date": "2017-12-02T05:00:00Z",
            "description": "Nhân dịp xuân về, đội văn nghệ của Nhà văn hóa thiếu nhi được cử đi biểu diễn giao lưu ở các phường trong thành phố. Đội văn nghệ có n bạn học sinh nam và m bạn học sinh nữ được chia thành các tổ, mỗi tổ sẽ đi phục vụ văn nghệ cho người dân ở các phường khác nhau. Biết rằng: số lượng học sinh nam và số lượng học sinh nữ phải được chia đều giữa các tổ và sau khi chia tổ, mỗi học sinh đều thuộc một tổ. Yêu cầu: Em hãy cho biết đội văn nghệ có thể chia nhiều nhất bao nhiêu tổ? Mỗi tổ có bao nhiêu học sinh nam và bao nhiêu học sinh nữ?\n\n## Sample Input\n\n    2\n    1 1\n    -1 0\n\n## Sample Output\n\n    2\n    -1",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "VNPN - Văn nghệ",
            "og_image": "",
            "partial": true,
            "points": 30.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 108
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "strng03",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Viết chương trình đếm số lượng từ có độ dài lớn hơn 3 trong một chuỗi nhập vào. Kết quả trả về số lượng từ thỏa mãn điều kiện.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đếm số từ trong chuỗi",
            "og_image": "",
            "partial": true,
            "points": 30.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 109
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "luckyday",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Giả sử bạn có một mảnh giấy với một số ô vuông. Mỗi ô có thể chứa một số. Viết chương trình tính toán tổng của tất cả các số có trong các ô vuông có tọa độ (x, y) sao cho x + y là số lẻ.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tính tổng số trong ô vuông",
            "og_image": "",
            "partial": true,
            "points": 30.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 110
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "oddball",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Trong một bảng chứa các số từ 1 đến n, một số được gọi là 'số lạ' nếu nó không thể chia hết cho bất kỳ số nào khác trong bảng. Viết chương trình để đếm số lượng 'số lạ' trong bảng.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Số lạ trong bảng",
            "og_image": "",
            "partial": true,
            "points": 30.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 111
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "graphdist",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị có hướng với n đỉnh và m cạnh. Viết chương trình tính khoảng cách ngắn nhất từ một đỉnh đến tất cả các đỉnh khác bằng thuật toán Dijkstra hoặc Bellman-Ford. Đồ thị có thể chứa chu trình âm và yêu cầu xử lý trường hợp này.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Khoảng cách ngắn nhất trong đồ thị có chu trình âm",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 112
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "segmenttree",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một dãy số, yêu cầu bạn xây dựng cây phân đoạn (Segment Tree) để xử lý các truy vấn sau: tính tổng các phần tử trong một đoạn cho trước và cập nhật giá trị của một phần tử trong dãy. Cây phân đoạn cần phải hoạt động hiệu quả cho các truy vấn lớn.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Cây phân đoạn (Segment Tree)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 113
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "optimalschedule",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một dãy các nhiệm vụ cần thực hiện, mỗi nhiệm vụ có một khoảng thời gian bắt đầu và kết thúc. Hãy lập trình để tính toán cách phân bổ tối ưu các nhiệm vụ sao cho không có hai nhiệm vụ nào bị trùng lịch. Bài toán yêu cầu thuật toán có thể xử lý hàng triệu nhiệm vụ với thời gian tính toán tối ưu.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Phân bổ nhiệm vụ tối ưu theo lịch trình không trùng lặp",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 114
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "pathfindinginmaze",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Trong một mê cung được biểu diễn dưới dạng ma trận với các ký tự '1' (tường) và '0' (lối đi), hãy viết chương trình tìm đường đi ngắn nhất từ điểm bắt đầu đến điểm đích. Cần sử dụng thuật toán tìm kiếm theo chiều rộng (BFS) để tìm đường đi và xử lý các trường hợp không tìm thấy lối đi.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm đường đi ngắn nhất trong mê cung sử dụng BFS",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 115
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "dijkstraongrid",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một lưới kích thước n x m, mỗi ô có một trọng số. Bạn cần tìm con đường có tổng trọng số nhỏ nhất từ ô bắt đầu đến ô đích, chỉ có thể di chuyển theo các hướng lên, xuống, trái, phải. Sử dụng thuật toán Dijkstra để tính toán quãng đường tối ưu trong lưới có trọng số.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tính quãng đường ngắn nhất trong lưới trọng số với Dijkstra",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 116
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "minimumspanningtree1",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị có n đỉnh và m cạnh, mỗi cạnh có trọng số. Hãy tìm cây bao trùm nhỏ nhất (MST) của đồ thị bằng cách sử dụng thuật toán Prim hoặc Kruskal. Đảm bảo rằng chương trình có thể xử lý đồ thị với số lượng đỉnh và cạnh rất lớn (lên đến 10^5).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm cây bao trùm nhỏ nhất trong đồ thị có trọng số - cải tiến",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 117
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "convexhull1",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một tập hợp các điểm trong mặt phẳng 2 chiều, hãy tìm và in ra các điểm tạo thành một bao lồi (convex hull) của các điểm này. Bài toán yêu cầu bạn sử dụng thuật toán Graham Scan hoặc QuickHull để tính toán bao lồi với độ phức tạp thời gian O(n log n).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tính bao lồi của một tập hợp điểm trong mặt phẳng - nâng cao",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 118
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maximumsubmatrix",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một ma trận n x m chứa các số nguyên. Hãy tìm một ma trận con có tổng các phần tử lớn nhất trong ma trận này. Bài toán yêu cầu bạn tối ưu hóa thuật toán để tìm ma trận con tối ưu với độ phức tạp thời gian O(n^2 * m).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm ma trận con có tổng lớn nhất trong ma trận",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 119
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "matrixgame",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một ma trận kích thước n x m, mỗi ô trong ma trận có giá trị điểm. Bạn và đối thủ lần lượt di chuyển trên ma trận từ ô này sang ô khác (theo các hướng lên, xuống, trái, phải) và cố gắng thu thập điểm. Ai thu được số điểm cao hơn sẽ chiến thắng. Bạn cần tính toán chiến lược di chuyển tối ưu cho bạn để có thể giành chiến thắng hoặc hòa.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Chiến lược chơi game trên ma trận",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 120
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "sparsegraph",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị thưa (sparse graph) với n đỉnh và m cạnh, mỗi cạnh có trọng số. Bạn cần tìm cây bao trùm tối thiểu (MST) sử dụng thuật toán Kruskal hoặc Prim. Tuy nhiên, bài toán yêu cầu bạn phải tối ưu hóa thuật toán để xử lý đồ thị thưa, nơi m << n^2.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm cây bao trùm tối thiểu cho đồ thị thưa",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 121
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "stringeditdistance",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho hai chuỗi ký tự, bạn cần tính toán khoảng cách chỉnh sửa (edit distance) giữa chúng, tức là số bước thay thế, chèn hoặc xóa ký tự để biến chuỗi này thành chuỗi kia. Tuy nhiên, bạn cần tối ưu hóa thuật toán để xử lý các chuỗi có độ dài lớn và độ phức tạp cao.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tính khoảng cách chỉnh sửa giữa hai chuỗi ký tự",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 122
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "graphcoloring1",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị không có hướng với n đỉnh và m cạnh. Mỗi đỉnh cần được tô màu sao cho không có hai đỉnh kề nhau có cùng màu. Tính số cách tô màu tối thiểu sao cho mọi đỉnh đều có màu khác nhau nếu cần. Bài toán yêu cầu bạn sử dụng thuật toán tối ưu cho các đồ thị phức tạp và tìm số màu tối thiểu (chromatic number).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tô màu đồ thị sao cho không có đỉnh kề nhau có màu giống nhau - nâng cao",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 123
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maxflowmincut",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một mạng lưới các đỉnh với các cạnh có trọng số, bạn cần tìm dòng chảy cực đại (maximum flow) từ nguồn đến đích. Bài toán yêu cầu bạn sử dụng thuật toán Ford-Fulkerson hoặc Edmonds-Karp để tính toán dòng chảy cực đại trong mạng. Đồng thời, bạn cũng cần tính toán cắt nhỏ nhất (minimum cut) cho mạng lưới này.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tính dòng chảy cực đại và cắt nhỏ nhất trong mạng lưới",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 124
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "subarrayoptimization",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một dãy số, hãy tìm dãy con liên tiếp có tổng lớn nhất trong dãy. Tuy nhiên, bạn không chỉ cần tính tổng lớn nhất mà còn phải tối ưu hóa cách tìm dãy con này với thời gian tính toán O(n) hoặc thấp hơn. Bài toán này yêu cầu ứng dụng thuật toán Kadane hoặc các biến thể của nó.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm dãy con liên tiếp có tổng lớn nhất trong dãy số",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 125
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "longestpalindromicsubsequence",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một chuỗi ký tự, hãy tìm độ dài của chuỗi con đối xứng dài nhất (palindromic subsequence) trong chuỗi này. Chuỗi con đối xứng có thể không cần các ký tự liên tiếp, nhưng phải duy trì thứ tự ban đầu của chúng. Bài toán yêu cầu bạn sử dụng phương pháp quy hoạch động để giải quyết với độ phức tạp thời gian O(n^2).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm chuỗi con đối xứng dài nhất trong chuỗi",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 126
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "kmpstringmatching",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho hai chuỗi, một chuỗi mẫu và một chuỗi tìm kiếm. Hãy sử dụng thuật toán KMP (Knuth-Morris-Pratt) để tìm tất cả các vị trí xuất hiện của chuỗi mẫu trong chuỗi tìm kiếm. Bài toán yêu cầu bạn triển khai thuật toán KMP với độ phức tạp O(n + m), trong đó n là độ dài chuỗi tìm kiếm và m là độ dài chuỗi mẫu.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm kiếm chuỗi mẫu bằng thuật toán KMP",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 127
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "optimalbinarysearchtree",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một dãy các giá trị và tần suất xuất hiện của chúng, bạn cần xây dựng một cây tìm kiếm nhị phân tối ưu (Optimal Binary Search Tree) sao cho tổng chi phí tìm kiếm trong cây là nhỏ nhất. Chi phí của mỗi truy vấn là tần suất của phần tử nhân với chiều cao của nút đó trong cây. Bài toán yêu cầu bạn áp dụng kỹ thuật quy hoạch động để giải quyết với độ phức tạp O(n^2).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Xây dựng cây tìm kiếm nhị phân tối ưu",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 128
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "minimumpathsum",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một ma trận các số nguyên, bạn cần tìm tổng nhỏ nhất từ ô trên cùng bên trái (top-left) đến ô dưới cùng bên phải (bottom-right) trong ma trận, di chuyển chỉ theo các hướng sang phải hoặc xuống. Bài toán yêu cầu bạn giải quyết bằng phương pháp quy hoạch động, tối ưu hóa để giảm thiểu bộ nhớ sử dụng.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm đường đi có tổng nhỏ nhất trong ma trận",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 129
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "fastfouriertransform",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một dãy các số phức, hãy tính biến đổi Fourier nhanh (FFT) để chuyển dãy này từ miền thời gian sang miền tần số. Bài toán yêu cầu bạn triển khai thuật toán FFT để xử lý dãy số dài và có độ phức tạp O(n log n), tối ưu hóa bộ nhớ và thời gian tính toán.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Biến đổi Fourier nhanh cho dãy số phức",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 130
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "graphbipartitecheck",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị không có hướng, bạn cần kiểm tra xem đồ thị này có phải là đồ thị hai phần (bipartite graph) hay không. Đồ thị hai phần là đồ thị mà các đỉnh có thể chia thành hai tập hợp sao cho không có hai đỉnh trong cùng một tập hợp nào có cạnh nối trực tiếp. Bài toán yêu cầu bạn sử dụng thuật toán tìm kiếm theo chiều rộng (BFS) hoặc theo chiều sâu (DFS) để kiểm tra tính hai phần của đồ thị.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra tính hai phần của đồ thị",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 131
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "longestcommonsubstring",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho hai chuỗi, hãy tìm độ dài của chuỗi con chung dài nhất (longest common substring) giữa hai chuỗi này. Một chuỗi con chung là một chuỗi con xuất hiện liên tiếp trong cả hai chuỗi. Bài toán yêu cầu bạn sử dụng thuật toán quy hoạch động với độ phức tạp O(n * m), trong đó n và m lần lượt là độ dài của hai chuỗi.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm chuỗi con chung dài nhất giữa hai chuỗi",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 132
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "matrixmultiplication",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho hai ma trận vuông A và B có kích thước n x n. Bạn cần tính tích của hai ma trận này (A * B). Bài toán yêu cầu bạn triển khai thuật toán nhân ma trận nhanh và tối ưu để tính toán với độ phức tạp O(n^3). Ngoài ra, bạn cũng cần kiểm tra các đặc tính ma trận như tính đối xứng hoặc chéo.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Nhân hai ma trận vuông",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 133
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "networkflow",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một mạng lưới với các đỉnh và các cạnh có trọng số, hãy tìm dòng chảy cực đại từ nguồn đến đích. Đối với bài toán này, bạn cần triển khai thuật toán Edmonds-Karp hoặc Ford-Fulkerson để tính toán dòng chảy cực đại và tìm cách tối ưu hóa thuật toán cho các mạng phức tạp với số đỉnh và cạnh lớn.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tính dòng chảy cực đại trong mạng lưới",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 134
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "lcs2d",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho hai chuỗi ký tự, hãy tìm chuỗi con chung dài nhất trong không gian 2 chiều. Chuỗi con chung dài nhất trong không gian này không yêu cầu các ký tự phải xuất hiện liên tiếp trong cả hai chuỗi, nhưng cần duy trì thứ tự xuất hiện. Bài toán yêu cầu sử dụng phương pháp quy hoạch động hai chiều với độ phức tạp O(n * m), trong đó n và m là độ dài của hai chuỗi.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm chuỗi con chung dài nhất trong không gian 2 chiều",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 135
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "graphdiameter",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị không có trọng số, hãy tìm đường đi dài nhất trong đồ thị, được gọi là đường kính của đồ thị (graph diameter). Bài toán yêu cầu bạn sử dụng thuật toán tìm kiếm theo chiều rộng (BFS) hoặc chiều sâu (DFS) để tìm đường kính của đồ thị trong thời gian O(V + E), với V là số đỉnh và E là số cạnh trong đồ thị.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm đường kính của đồ thị",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 136
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "knapsackproblem1",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một tập hợp các vật phẩm với trọng lượng và giá trị cho trước, hãy chọn các vật phẩm sao cho tổng trọng lượng không vượt quá một giá trị cho trước, và tổng giá trị là lớn nhất có thể. Bài toán yêu cầu bạn giải quyết bài toán ba chiều với các ràng buộc bổ sung, sử dụng quy hoạch động với độ phức tạp O(n * W), trong đó n là số lượng vật phẩm và W là giới hạn trọng lượng.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán ba chiều",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 137
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "sparsegraphtraversal",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị thưa (sparse graph), hãy tìm tất cả các đỉnh có thể tiếp cận từ một đỉnh xuất phát cho trước. Đồ thị này có thể có trọng số, nhưng yêu cầu bài toán là tìm kiếm theo chiều rộng (BFS) hoặc chiều sâu (DFS) để duyệt qua đồ thị và tính toán các đỉnh có thể tiếp cận. Bài toán yêu cầu tối ưu hóa thuật toán cho đồ thị lớn và thưa.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Duyệt đồ thị thưa",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 138
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "editdistanceoptimization",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho hai chuỗi, bạn cần tính khoảng cách chỉnh sửa (edit distance) giữa chúng. Bài toán yêu cầu tối ưu hóa thuật toán tính toán khoảng cách chỉnh sửa với các kịch bản đặc biệt, ví dụ như khi có nhiều ký tự giống nhau trong cả hai chuỗi, hoặc khi có các ký tự đặc biệt. Bạn cần triển khai thuật toán động với độ phức tạp O(n * m) nhưng tối ưu hóa bộ nhớ.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tính khoảng cách chỉnh sửa với tối ưu hóa bộ nhớ",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 139
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maxflowoptimization",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một mạng lưới với các đỉnh và các cạnh có trọng số, bạn cần tính dòng chảy cực đại từ nguồn đến đích. Bài toán yêu cầu tối ưu hóa thuật toán Edmonds-Karp hoặc Ford-Fulkerson để xử lý với các mạng phức tạp có số lượng đỉnh và cạnh lớn. Bạn cần cải tiến thuật toán với phương pháp tăng cường và các chiến lược cắt mạng (network cuts).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tối ưu hóa dòng chảy cực đại trong mạng lưới",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 140
    },
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "fibonaccioptimization",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một số nguyên n, hãy tính giá trị của dãy số Fibonacci thứ n. Tuy nhiên, bài toán yêu cầu bạn tối ưu hóa thuật toán để tính giá trị Fibonacci trong thời gian O(log n) bằng cách sử dụng ma trận lũy thừa. Bạn cần triển khai phương pháp ma trận nhanh để tính giá trị Fibonacci trong thời gian cực nhanh.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tính giá trị Fibonacci với tối ưu hóa ma trận",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 141
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "tspdynamic",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị có trọng số, tìm đường đi ngắn nhất đi qua tất cả các đỉnh đúng một lần và quay lại điểm xuất phát (tức là bài toán du lịch salesman - TSP). Bài toán yêu cầu bạn sử dụng phương pháp quy hoạch động để tối ưu hóa độ phức tạp. Bạn cần giải quyết bài toán TSP với thời gian O(n * 2^n), trong đó n là số lượng đỉnh của đồ thị.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Giải bài toán du lịch salesman với quy hoạch động",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 142
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "dpminpathsum",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một ma trận vuông n x n, mỗi phần tử trong ma trận là một số nguyên dương, hãy tìm tổng giá trị nhỏ nhất từ góc trên bên trái đến góc dưới bên phải. Bạn có thể di chuyển chỉ theo hướng xuống hoặc sang phải. Bài toán yêu cầu bạn sử dụng phương pháp quy hoạch động để giải quyết với độ phức tạp O(n^2).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm đường đi có tổng giá trị nhỏ nhất trong ma trận",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 143
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "matrixmultiplication1",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho hai ma trận vuông A và B kích thước n x n, bạn cần tính tích của chúng. Tuy nhiên, bài toán yêu cầu tối ưu hóa thuật toán nhân ma trận. Bạn cần áp dụng thuật toán Strassen để giảm độ phức tạp từ O(n^3) xuống O(n^log2(7)) để nhân hai ma trận lớn một cách hiệu quả.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Nhân ma trận với thuật toán Strassen",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 144
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "bipartitematching",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị không có trọng số, bạn cần xác định xem đồ thị có phải là đồ thị phân hoạch (bipartite) hay không. Nếu có, bài toán yêu cầu bạn tìm một cặp đồ thị phân hoạch tối đa, tức là tìm một cặp đỉnh trong đồ thị mà không có cạnh nối trực tiếp giữa chúng. Bạn cần sử dụng thuật toán tìm kiếm theo chiều rộng (BFS) hoặc chiều sâu (DFS) để xác định đồ thị có phải là bipartite và tìm cặp phân hoạch tối đa.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Kiểm tra đồ thị phân hoạch và tìm cặp tối đa",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 145
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "longestincreasingsubsequence",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một dãy số, hãy tìm dãy con tăng dài nhất (LIS - Longest Increasing Subsequence). Bài toán yêu cầu bạn tìm cách tối ưu hóa việc tính toán dãy con tăng dài nhất với độ phức tạp O(n log n), sử dụng thuật toán nhị phân để duy trì dãy con tăng trong quá trình duyệt qua các phần tử của dãy.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm dãy con tăng dài nhất với tối ưu hóa nhị phân",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 146
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "matrixchainmultiplication1",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một dãy các ma trận với kích thước n x m, bạn cần tìm cách nhân chúng lại với nhau sao cho số phép toán nhân là tối thiểu. Bài toán này gọi là bài toán chuỗi ma trận (Matrix Chain Multiplication). Hãy sử dụng quy hoạch động để giải quyết bài toán với độ phức tạp O(n^3).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán chuỗi ma trận - cải tiến",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 147
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "knapsackwithfractions",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một túi với sức chứa W và n món đồ, mỗi món đồ có trọng lượng và giá trị nhất định. Bạn cần chọn một tập con các món đồ sao cho tổng giá trị của chúng là lớn nhất, nhưng tổng trọng lượng không vượt quá W. Tuy nhiên, các món đồ có thể được chia nhỏ, và bạn có thể chọn phần nào đó của món đồ. Bài toán yêu cầu bạn giải quyết bằng thuật toán tham lam (Greedy) với độ phức tạp O(n log n).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán túi xách với đồ vật có thể chia nhỏ",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 148
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "dijkstrashortestpath",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị có trọng số, bạn cần tìm đường đi ngắn nhất từ một đỉnh đến tất cả các đỉnh còn lại. Bài toán yêu cầu bạn sử dụng thuật toán Dijkstra để giải quyết với độ phức tạp O((V + E) log V), trong đó V là số đỉnh và E là số cạnh của đồ thị.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm đường đi ngắn nhất bằng thuật toán Dijkstra",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 149
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "travellingsalesman1",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị có n đỉnh và m cạnh, bài toán yêu cầu bạn tìm đường đi ngắn nhất sao cho bạn đi qua tất cả các đỉnh đúng một lần và trở lại điểm xuất phát. Đây là bài toán salesman du lịch (Traveling Salesman Problem - TSP), một bài toán NP-hard. Bạn cần áp dụng thuật toán tối ưu gần đúng hoặc thuật toán tìm kiếm theo dõi để giải quyết bài toán này cho các đồ thị có kích thước vừa phải.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán salesman du lịch - nâng cao",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 150
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "convexhull",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một tập hợp các điểm trên mặt phẳng 2D, bài toán yêu cầu bạn tìm tập hợp các điểm tạo thành bao lồi (Convex Hull) của các điểm đó. Hãy sử dụng thuật toán Graham Scan hoặc thuật toán QuickHull để giải quyết bài toán với độ phức tạp O(n log n), trong đó n là số điểm.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm bao lồi của một tập hợp điểm",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 151
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "matrixexponentiation",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một ma trận vuông A có kích thước n x n và một số m, bạn cần tính A^m (ma trận A lũy thừa m) với m có thể rất lớn. Bài toán yêu cầu bạn sử dụng phương pháp lũy thừa ma trận nhanh (Matrix Exponentiation) với độ phức tạp O(log m) để tính toán ma trận lũy thừa.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Lũy thừa ma trận nhanh (Matrix Exponentiation)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 152
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "flowingwater",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một dòng sông với các đoạn có chiều dài và độ dốc khác nhau, bạn cần tìm cách di chuyển vật nặng từ đầu nguồn đến cuối sông sao cho tổng năng lượng tiêu tốn là nhỏ nhất. Mỗi đoạn sông có độ dốc khác nhau sẽ làm thay đổi năng lượng tiêu tốn. Bài toán yêu cầu bạn áp dụng thuật toán dòng chảy tối thiểu (Min-Cost Flow) để tính toán cách di chuyển với chi phí thấp nhất. Độ phức tạp thuật toán yêu cầu là O(VE^2).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Dòng chảy năng lượng tối thiểu (Min-Cost Flow)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 153
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "palindromicsubsequence",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một chuỗi ký tự, bạn cần tìm chuỗi con đối xứng dài nhất có thể có trong chuỗi ban đầu. Bài toán yêu cầu sử dụng thuật toán quy hoạch động để tính chuỗi con đối xứng dài nhất với độ phức tạp O(n^2), trong đó n là độ dài của chuỗi ban đầu.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Chuỗi con đối xứng dài nhất (Longest Palindromic Subsequence)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 154
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maximizingprofits",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một dãy các hoạt động với chi phí và lợi nhuận tương ứng, bạn cần tối đa hóa lợi nhuận sau khi thực hiện một số hoạt động nhất định trong thời gian cho phép. Bài toán này có thể giải quyết bằng cách sử dụng thuật toán tham lam (Greedy) với độ phức tạp O(n log n), trong đó n là số lượng hoạt động.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tối đa hóa lợi nhuận từ các hoạt động (Maximizing Profits)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 155
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "kthshortestpath",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho đồ thị có trọng số, bài toán yêu cầu bạn tìm đường đi ngắn nhất thứ k từ một đỉnh đến một đỉnh khác. Để giải quyết bài toán này, bạn cần sử dụng thuật toán K-th shortest path, một mở rộng của thuật toán Dijkstra hoặc A*, với độ phức tạp O((V + E) log V).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đường đi ngắn nhất thứ k (K-th Shortest Path)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 156
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "longestpathinDAG",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho đồ thị có hướng (DAG) với trọng số các cạnh, bạn cần tìm đường đi dài nhất trong đồ thị. Bài toán này có thể giải quyết bằng cách sử dụng thuật toán quy hoạch động (Dynamic Programming) trên đồ thị acyclic có hướng với độ phức tạp O(V + E), trong đó V là số đỉnh và E là số cạnh.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đường đi dài nhất trong đồ thị có hướng (Longest Path in DAG)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 157
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maximummatching",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị không có hướng, bài toán yêu cầu bạn tìm cặp ghép lớn nhất (Maximum Matching) trong đồ thị. Bạn có thể sử dụng thuật toán Hungarian hoặc thuật toán Hopcroft-Karp để giải quyết bài toán này với độ phức tạp O(√V * E).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Cặp ghép lớn nhất trong đồ thị (Maximum Matching)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 158
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maximumsubarraysum",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một mảng số nguyên, bài toán yêu cầu tìm tổng của dãy con có tổng lớn nhất. Đây là bài toán cổ điển, yêu cầu áp dụng thuật toán Kadane để tìm tổng dãy con lớn nhất với độ phức tạp O(n), trong đó n là số phần tử của mảng.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tổng dãy con lớn nhất (Maximum Subarray Sum)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 159
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "graphcoloring2",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho đồ thị không có chu trình, bài toán yêu cầu bạn tô màu các đỉnh sao cho không có hai đỉnh kề nhau có màu giống nhau. Tìm số lượng màu tối thiểu cần thiết để tô màu đồ thị. Đây là bài toán của lý thuyết đồ thị có thể giải quyết bằng thuật toán tìm màu tối thiểu với độ phức tạp O(V + E).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tô màu đồ thị (Graph Coloring)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 160
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "floydwarshalloptimizations",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho đồ thị có trọng số và có thể có chu trình, bài toán yêu cầu tính toán tất cả các cặp đường đi ngắn nhất từ mọi đỉnh đến mọi đỉnh còn lại trong đồ thị. Bạn có thể sử dụng thuật toán Floyd-Warshall, tuy nhiên cần tối ưu hóa thuật toán này để đạt được độ phức tạp O(V^3).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tối ưu hóa thuật toán Floyd-Warshall (Floyd-Warshall Optimizations)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 161
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maximumflow",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho đồ thị có hướng với các đỉnh và cạnh có trọng số, bài toán yêu cầu bạn tìm dòng chảy lớn nhất (Maximum Flow) từ một nguồn đến một đích trong đồ thị. Bạn có thể sử dụng thuật toán Edmonds-Karp hoặc Dinic để giải quyết bài toán này với độ phức tạp O(V^2 * E) hoặc O(V^3), trong đó V là số đỉnh và E là số cạnh của đồ thị.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Dòng chảy lớn nhất trong đồ thị (Maximum Flow)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 162
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "subsetsum",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một tập hợp các số nguyên, bài toán yêu cầu bạn tìm xem có thể chia tập hợp thành hai phần sao cho tổng các phần tử trong mỗi phần là bằng nhau. Bài toán này có thể giải quyết bằng cách sử dụng phương pháp quy hoạch động (Dynamic Programming) với độ phức tạp O(n * S), trong đó n là số phần tử trong tập hợp và S là tổng của tất cả các phần tử.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Chia tập hợp thành hai phần có tổng bằng nhau (Subset Sum)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 163
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "knapsackproblem2",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một tập hợp các đồ vật với trọng lượng và giá trị, bài toán yêu cầu bạn chọn một số đồ vật sao cho tổng giá trị là lớn nhất mà tổng trọng lượng không vượt quá một giới hạn nhất định. Bài toán này có thể giải quyết bằng cách sử dụng thuật toán quy hoạch động (Dynamic Programming) với độ phức tạp O(n * W), trong đó n là số đồ vật và W là trọng lượng tối đa.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán Knapsack - giá trị",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 164
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "travelingsalesman",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một tập hợp các thành phố và khoảng cách giữa các thành phố, bài toán yêu cầu bạn tìm lộ trình ngắn nhất đi qua tất cả các thành phố mà không đi qua thành phố nào hai lần. Đây là bài toán cổ điển trong lý thuyết đồ thị, có thể giải quyết bằng cách sử dụng thuật toán Brute Force, nhưng với số lượng thành phố lớn, bạn cần tối ưu hóa bằng thuật toán DP với độ phức tạp O(n^2 * 2^n).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán lộ trình đi trong thành phố",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 165
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "dijkstrastate",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị có trọng số, bài toán yêu cầu bạn tìm đường đi ngắn nhất từ một đỉnh đến một đỉnh khác, nhưng với yêu cầu đặc biệt: mỗi lần bạn di chuyển từ một đỉnh sang đỉnh khác, trạng thái của đỉnh thay đổi, có thể thay đổi trọng số hoặc các thuộc tính khác. Bài toán này yêu cầu áp dụng thuật toán Dijkstra với trạng thái thay đổi (Dijkstra with state) và có thể phải sử dụng thêm cấu trúc dữ liệu như priority queue để tối ưu hóa.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đường đi ngắn nhất với trạng thái thay đổi (Dijkstra with State)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 166
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "mincostmaxflow1",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho đồ thị có hướng với các đỉnh và cạnh có trọng số, bài toán yêu cầu bạn tìm dòng chảy lớn nhất với chi phí thấp nhất từ một nguồn đến một đích. Đây là bài toán kết hợp giữa dòng chảy lớn nhất (Maximum Flow) và chi phí tối thiểu (Min-Cost). Bạn có thể sử dụng thuật toán Min-Cost Max Flow, thường được giải quyết bằng cách kết hợp thuật toán Ford-Fulkerson với thuật toán Bellman-Ford hoặc SPFA để tối ưu hóa chi phí.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Dòng chảy tối thiểu chi phí - nâng cao",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 167
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maximalclique",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị vô hướng với n đỉnh, bài toán yêu cầu bạn tìm tập đỉnh con sao cho trong tập đỉnh con đó, mọi cặp đỉnh đều có cạnh nối với nhau. Tập đỉnh này gọi là một clique. Bạn cần tìm clique lớn nhất trong đồ thị này, tức là tìm tập đỉnh con có kích thước lớn nhất sao cho mọi cặp đỉnh trong tập đều được nối với nhau. Đây là bài toán NP-hard, có thể giải quyết bằng cách sử dụng thuật toán tìm kiếm tuần tự hoặc quy hoạch động.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm clique lớn nhất trong đồ thị (Maximal Clique)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 168
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "mincut",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị có hướng, bài toán yêu cầu bạn tìm cắt tối thiểu trong đồ thị giữa một nguồn và một đích. Cắt tối thiểu là một tập hợp các cạnh có trọng số sao cho nếu loại bỏ chúng khỏi đồ thị, không còn đường đi nào từ nguồn đến đích. Bài toán này có thể giải quyết bằng cách sử dụng thuật toán Ford-Fulkerson kết hợp với phương pháp tìm kiếm cắt tối thiểu như thuật toán Edmonds-Karp, với độ phức tạp O(V^2 * E).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm cắt tối thiểu trong đồ thị (Min Cut)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 169
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "longestpath2",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị có hướng với các trọng số trên các cạnh, bài toán yêu cầu bạn tìm đường đi dài nhất giữa hai đỉnh trong đồ thị. Đường đi dài nhất trong đồ thị có thể giải quyết bằng cách sử dụng thuật toán tìm đường đi tối ưu (Dijkstra hoặc Bellman-Ford) với điều kiện là đồ thị không có chu trình âm. Nếu đồ thị có chu trình âm, bạn cần sử dụng thuật toán khác như thuật toán Bellman-Ford để phát hiện chu trình và xử lý đặc biệt.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm đường đi dài nhất trong đồ thị (Longest Path)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 170
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maximumindependentset",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị vô hướng với n đỉnh và m cạnh, bài toán yêu cầu bạn tìm tập đỉnh độc lập lớn nhất trong đồ thị. Tập đỉnh độc lập là một tập các đỉnh sao cho không có hai đỉnh nào trong tập đó nối với nhau bằng một cạnh. Đây là một bài toán NP-hard, có thể giải quyết bằng cách sử dụng thuật toán tìm kiếm toàn diện hoặc thuật toán xấp xỉ.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm tập đỉnh độc lập lớn nhất (Maximum Independent Set)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 171
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maximumbipartitematching",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị bipartite (đồ thị hai phía) với n đỉnh và m cạnh, bài toán yêu cầu bạn tìm số lượng cặp đỉnh tối đa mà mỗi cặp đỉnh này đều được nối với nhau bằng một cạnh. Bài toán này có thể giải quyết bằng cách sử dụng thuật toán tìm kiếm theo chiều sâu (DFS) kết hợp với thuật toán tìm kiếm tham lam hoặc sử dụng phương pháp Ford-Fulkerson để giải quyết bài toán matching trong đồ thị bipartite.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tìm matching tối đa trong đồ thị bipartite (Maximum Bipartite Matching)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 172
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "knapsackwithfactors",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một bài toán ba lô (Knapsack) với n vật phẩm và một giới hạn trọng lượng W, bài toán yêu cầu tìm cách chọn các vật phẩm sao cho tổng giá trị của các vật phẩm được chọn là lớn nhất, nhưng mỗi vật phẩm có thể có các yếu tố ảnh hưởng đến giá trị hoặc trọng lượng của nó, như các yếu tố điều kiện (factors). Bạn cần áp dụng thuật toán DP với các yếu tố bổ sung này để tính toán tối ưu.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán ba lô với các yếu tố ảnh hưởng (Knapsack with Factors)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 173
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "subsetsumproblem",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một mảng số nguyên có n phần tử, bài toán yêu cầu bạn kiểm tra xem có tồn tại một tập con nào của mảng có tổng bằng một giá trị cho trước S. Đây là bài toán kinh điển trong lý thuyết tập hợp, có thể giải quyết bằng phương pháp quy hoạch động hoặc thuật toán tìm kiếm nhị phân. Tuy nhiên, khi n trở nên rất lớn, bài toán có thể yêu cầu tối ưu hóa để xử lý hiệu quả.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Bài toán tập con có tổng bằng S (Subset Sum Problem)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 174
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "dijkstraextended",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị có hướng và trọng số, bài toán yêu cầu tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh còn lại, nhưng với điều kiện là mỗi đỉnh chỉ có thể được truy cập tối đa k lần. Bạn cần tối ưu hóa thuật toán Dijkstra để xử lý thêm điều kiện giới hạn số lần truy cập vào mỗi đỉnh. Đây là một biến thể phức tạp của bài toán Dijkstra thông thường.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Dijkstra với giới hạn truy cập đỉnh (Dijkstra with Vertex Access Limit)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 175
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "networkflowmaximummatching",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một mạng lưới đồ thị có hướng với các cạnh có dung lượng, bài toán yêu cầu bạn tìm số lượng tối đa các cặp đỉnh có thể được nối với nhau sao cho tổng dung lượng các cạnh là tối đa, đồng thời mỗi đỉnh chỉ có thể tham gia vào một cặp. Đây là bài toán matching tối đa trong mạng lưới với điều kiện dung lượng cạnh, có thể giải quyết bằng cách sử dụng thuật toán tìm dòng chảy tối đa (Max-Flow) kết hợp với thuật toán tìm matching tối đa.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Matching tối đa trong mạng lưới với dung lượng (Maximum Matching in Network Flow)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 176
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "longestcommonsubstringwithkmodification",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho hai chuỗi s1 và s2, bài toán yêu cầu bạn tìm chuỗi con chung dài nhất có thể giữa hai chuỗi này, với điều kiện rằng bạn có thể thực hiện tối đa k phép thay đổi trên các ký tự của s1 và s2 để làm cho chuỗi con chung dài hơn. Mỗi phép thay đổi cho phép thay đổi một ký tự bất kỳ trong s1 hoặc s2 thành ký tự khác. Bạn cần tối ưu hóa thuật toán DP để xử lý điều kiện k thay đổi này.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Chuỗi con chung dài nhất với k phép thay đổi (Longest Common Substring with k Modifications)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 177
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "mincutmaxflownetwork",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một mạng lưới đồ thị có hướng với các cạnh có dung lượng, bài toán yêu cầu bạn tìm cắt tối thiểu (min-cut) trong mạng lưới giữa hai đỉnh cho trước. Bài toán này có thể giải quyết bằng cách sử dụng định lý Max-Flow Min-Cut, kết hợp với thuật toán Ford-Fulkerson hoặc Edmonds-Karp để tính toán dòng chảy tối đa, từ đó xác định cắt tối thiểu trong mạng lưới.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Cắt tối thiểu trong mạng lưới với dòng chảy tối đa (Min-Cut in Network Flow)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 178
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "groupbyshapes",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một tập hợp các hình học (đường tròn, hình vuông, tam giác, ...) với các tọa độ và kích thước của chúng. Bài toán yêu cầu bạn nhóm các hình học lại với nhau sao cho các hình trong cùng một nhóm phải có các đặc điểm tương đồng về hình dạng (ví dụ: tất cả đều là đường tròn, hoặc đều có kích thước gần giống nhau). Bạn cần tối ưu hóa thuật toán để tìm nhóm hình học tương đồng với các đặc điểm tối thiểu.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Nhóm các hình học theo đặc điểm (Group By Shapes)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 179
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "highdimensionalknapsack",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Bài toán này là một biến thể của bài toán Knapsack cổ điển, nhưng với nhiều chiều (nhiều yếu tố như trọng lượng, giá trị, và kích thước) cho mỗi vật phẩm. Bạn cần tối ưu hóa việc chọn vật phẩm sao cho tổng giá trị đạt được là lớn nhất, nhưng không vượt quá các giới hạn cho từng chiều. Đây là bài toán khó và có thể yêu cầu sử dụng quy hoạch động hoặc các kỹ thuật tối ưu hóa khác như tìm kiếm nhánh cắt.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Knapsack đa chiều (High-Dimensional Knapsack)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 180
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "longestpathwithconstraints",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị có hướng, bài toán yêu cầu bạn tìm đường đi dài nhất từ một đỉnh nguồn đến một đỉnh đích, nhưng với các ràng buộc về chiều dài của mỗi đoạn đường. Mỗi đoạn đường có thể có một trọng số nhất định và bạn cần tối ưu hóa để tìm đường đi dài nhất trong khi đảm bảo rằng không có đoạn đường nào vượt quá giới hạn trọng số. Đây là bài toán phức tạp trong lý thuyết đồ thị, yêu cầu sử dụng thuật toán tìm kiếm tối ưu.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đường đi dài nhất với ràng buộc (Longest Path with Constraints)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 181
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "maximumflowwithspecialconstraints",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Bài toán này yêu cầu bạn giải quyết một bài toán dòng chảy tối đa (Max-Flow) trong đồ thị với các ràng buộc đặc biệt. Cụ thể, bạn cần tối ưu hóa dòng chảy giữa các đỉnh, nhưng với điều kiện rằng dòng chảy không thể vượt quá một số lượng cụ thể cho các đỉnh hoặc các cạnh nhất định trong đồ thị. Bạn sẽ cần phải áp dụng thuật toán Max-Flow với các cải tiến để xử lý các ràng buộc này.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Dòng chảy tối đa với ràng buộc đặc biệt (Max-Flow with Special Constraints)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 182
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "multidimensionalknapsackwithbounds",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Bài toán này là một biến thể của bài toán Knapsack đa chiều, nhưng với các giới hạn khác nhau trên từng chiều. Mỗi vật phẩm có nhiều thuộc tính (ví dụ như trọng lượng, giá trị, kích thước), và mỗi chiều có một giới hạn riêng. Bạn cần tối ưu hóa để chọn các vật phẩm sao cho tổng giá trị lớn nhất mà không vi phạm bất kỳ giới hạn nào trong các chiều. Thuật toán cần tối ưu hóa các chiều và áp dụng quy hoạch động phức tạp để giải quyết bài toán này.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Knapsack đa chiều với giới hạn (Multidimensional Knapsack with Bounds)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 183
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "shortestpathwithcycleelimination",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Cho một đồ thị có hướng với các cạnh có trọng số, bài toán yêu cầu bạn tìm đường đi ngắn nhất từ một đỉnh nguồn đến đỉnh đích, nhưng với điều kiện rằng bạn cần loại bỏ tất cả các chu trình (cycle) trong đồ thị trước khi tính toán đường đi. Đây là một biến thể phức tạp của bài toán đường đi ngắn nhất, yêu cầu bạn sử dụng các kỹ thuật loại bỏ chu trình và tìm kiếm tối ưu trong đồ thị.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Đường đi ngắn nhất với loại bỏ chu trình (Shortest Path with Cycle Elimination)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 184
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "flownetworkwithtimeconstraints",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Bài toán này yêu cầu bạn tính toán dòng chảy tối đa trong một mạng lưới với các ràng buộc về thời gian. Mỗi cạnh trong đồ thị có một thời gian di chuyển cụ thể và một dung lượng dòng chảy. Bạn cần tìm dòng chảy tối đa từ một đỉnh nguồn đến đỉnh đích, nhưng với điều kiện rằng tổng thời gian di chuyển không được vượt quá một giới hạn nhất định. Đây là bài toán phức tạp yêu cầu bạn tối ưu hóa thuật toán dòng chảy tối đa với các giới hạn thời gian.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Mạng lưới dòng chảy với ràng buộc thời gian (Flow Network with Time Constraints)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 185
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "multiobjectiveoptimizationnetworkflow",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Bài toán này yêu cầu bạn giải quyết một bài toán dòng chảy tối đa trong mạng lưới, nhưng với mục tiêu tối ưu hóa đồng thời nhiều mục tiêu. Mỗi cạnh trong đồ thị có hai thuộc tính trọng số: một cho dòng chảy và một cho chi phí. Bạn cần tìm dòng chảy tối đa sao cho tổng chi phí và tổng dòng chảy đạt được là tối ưu nhất theo một số hàm mục tiêu cụ thể. Bài toán này yêu cầu bạn sử dụng các phương pháp tối ưu hóa đa mục tiêu như các thuật toán tìm kiếm Pareto.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Tối ưu hóa đa mục tiêu trong mạng dòng chảy (Multi-objective Optimization in Network Flow)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 186
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "matrixmultiplicationwithconstraints",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Bài toán này yêu cầu bạn thực hiện phép nhân ma trận với các ràng buộc về cấu trúc ma trận. Cụ thể, bạn cần nhân hai ma trận lớn, nhưng có giới hạn về số lượng phép toán có thể thực hiện (số phép cộng và nhân trong phép nhân ma trận). Bạn phải tối ưu hóa thứ tự phép nhân ma trận và chọn phương pháp nhân sao cho số lượng phép toán là ít nhất, đồng thời đảm bảo kết quả đúng. Bài toán này yêu cầu bạn sử dụng các kỹ thuật tối ưu hóa như phân tách ma trận (matrix splitting).",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Nhân ma trận với ràng buộc (Matrix Multiplication with Constraints)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 187
    }
    ,
    {
        "fields": {
            "ac_rate": 0.0,
            "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
            "authors": [1],
            "banned_users": [],
            "code": "longestcommonsequencewithgaps",
            "curators": [],
            "date": "2024-12-20T05:00:00Z",
            "description": "Bài toán này yêu cầu bạn tìm chuỗi con chung dài nhất giữa hai chuỗi cho trước, nhưng với điều kiện rằng bạn có thể bỏ qua một số ký tự (gaps) trong chuỗi khi so sánh. Đây là một bài toán mở rộng của bài toán chuỗi con chung dài nhất, yêu cầu bạn sử dụng các kỹ thuật tìm kiếm động, nhưng với các điều kiện phụ về việc cho phép bỏ qua ký tự khi so sánh hai chuỗi.",
            "group": 4,
            "is_manually_managed": false,
            "is_public": true,
            "license": null,
            "memory_limit": 65536,
            "name": "Chuỗi con chung dài nhất với khoảng trống (Longest Common Subsequence with Gaps)",
            "og_image": "",
            "partial": true,
            "points": 50.0,
            "short_circuit": false,
            "summary": "",
            "testers": [],
            "time_limit": 5.0,
            "types": [11, 16],
            "user_count": 0
        },
        "model": "judge.problem",
        "pk": 188
    }
    ,
    {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "dynamicprogrammingknapsackwithtime",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán này là biến thể của bài toán ba lô (Knapsack Problem), nhưng với một yếu tố bổ sung là thời gian. Bạn có một tập hợp các vật phẩm, mỗi vật phẩm có trọng lượng, giá trị và thời gian cần để vận chuyển. Mục tiêu là tối đa hóa giá trị tổng của các vật phẩm trong ba lô, nhưng với một ràng buộc về tổng trọng lượng và thời gian mà bạn có thể sử dụng. Bài toán này yêu cầu bạn áp dụng phương pháp lập trình động để giải quyết.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Ba lô động với thời gian (Dynamic Programming Knapsack with Time)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 189
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "graphcoloringwithconstraints",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán này yêu cầu bạn tô màu đồ thị sao cho không có hai đỉnh kề nhau có cùng màu. Tuy nhiên, có một số ràng buộc bổ sung về số lượng màu sắc tối đa có thể sử dụng và một số đỉnh phải có màu nhất định. Mục tiêu là tìm một cách tô màu hợp lệ với số màu tối thiểu trong các ràng buộc đã cho. Bài toán này yêu cầu bạn sử dụng các thuật toán đồ thị để giải quyết.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tô màu đồ thị với ràng buộc (Graph Coloring with Constraints)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 190
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "pathfindingin3dgrid",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán này yêu cầu bạn tìm đường đi ngắn nhất trong một lưới 3D, từ một điểm đầu đến một điểm kết thúc, với các ràng buộc về địa hình (ví dụ: các ô tường hoặc vật cản). Bạn cần sử dụng thuật toán tìm kiếm như A* hoặc Dijkstra để tìm ra lộ trình hợp lý nhất trong không gian ba chiều, trong đó mỗi bước di chuyển có thể có chi phí khác nhau tùy thuộc vào độ dốc của địa hình.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm đường trong lưới 3D (Pathfinding in 3D Grid)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 191
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "longestpathindaggedgraph",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm đường đi dài nhất trong một đồ thị có trọng số âm, trong đó các cạnh có thể bị gián đoạn (cắt, đoạn không thể đi qua). Bạn cần xác định đường đi dài nhất từ một đỉnh nguồn đến một đỉnh đích, với các cạnh có thể bị gián đoạn hoặc có trọng số âm. Đây là bài toán đồ thị đòi hỏi phải áp dụng các thuật toán đặc biệt như Bellman-Ford hoặc Dijkstra mở rộng.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Đường đi dài nhất trong đồ thị có trọng số âm và gián đoạn (Longest Path in a Dagged Graph)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 192
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "minimumspanningtreewithconstraints",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu bạn tìm cây khung nhỏ nhất (MST) của đồ thị có trọng số, nhưng với một số ràng buộc nhất định. Các ràng buộc này có thể là: một số cạnh không được chọn, hoặc trọng số của các cạnh cần phải đạt một giá trị nhất định. Bài toán này yêu cầu bạn áp dụng thuật toán Kruskal hoặc Prim với các điều kiện bổ sung về trọng số và các cạnh bị loại trừ.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Cây khung nhỏ nhất với ràng buộc (Minimum Spanning Tree with Constraints)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 193
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "minimizingweightedgraphtraversal",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu bạn tối thiểu hóa tổng trọng số trong quá trình duyệt qua đồ thị, trong đó các đỉnh có trọng số khác nhau và mỗi cạnh có một trọng số đi kèm. Mục tiêu là duyệt qua các đỉnh của đồ thị sao cho tổng trọng số của các đỉnh và các cạnh trong đường đi là nhỏ nhất. Thuật toán này yêu cầu bạn sử dụng các kỹ thuật như Dijkstra hoặc thuật toán tìm kiếm tối ưu trong đồ thị.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tối thiểu hóa trọng số khi duyệt qua đồ thị (Minimizing Weighted Graph Traversal)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 194
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "multidimensionalknapsack",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán là một biến thể của bài toán ba lô (Knapsack Problem) trong đó bạn phải đối mặt với nhiều chiều khác nhau của ba lô (ví dụ: trọng lượng, thể tích, giá trị). Bạn cần chọn các vật phẩm sao cho tối ưu hóa tổng giá trị, đồng thời không vượt quá giới hạn của mỗi chiều. Bài toán này yêu cầu sử dụng các kỹ thuật lập trình động để tối ưu hóa việc chọn các vật phẩm.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Ba lô đa chiều (Multidimensional Knapsack)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 195
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "minimumpathcoverindaggedgraph",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm một cách tô màu tối thiểu cho các cạnh của một đồ thị có hướng sao cho không có hai đỉnh cùng một lúc trong cùng một màu. Đồ thị có thể có các cạnh bị gián đoạn (mất kết nối). Mục tiêu là tìm một cách tô màu các đỉnh sao cho số lượng màu tối thiểu được sử dụng. Đây là bài toán đòi hỏi sự sáng tạo trong việc sử dụng các thuật toán tối ưu đồ thị như Hopcroft-Karp hoặc các biến thể khác.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Cây bao phủ đường đi tối thiểu trong đồ thị có hướng (Minimum Path Cover in a Dagged Graph)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 196
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "parallelprocessingoptimization",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán này yêu cầu tối ưu hóa quá trình xử lý song song, trong đó bạn cần phân bổ công việc giữa các lõi xử lý sao cho tổng thời gian thực hiện là tối thiểu. Bạn sẽ có một số tác vụ có độ phức tạp khác nhau và một số lõi xử lý. Mỗi lõi xử lý có thể thực hiện một số tác vụ, và bạn cần phân bổ công việc sao cho thời gian thực hiện của tất cả các lõi xử lý là ngắn nhất. Đây là bài toán tối ưu hóa phân bổ công việc song song.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tối ưu hóa xử lý song song (Parallel Processing Optimization)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 197
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "maximalindependentset",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm tập độc lập lớn nhất trong đồ thị, tức là một tập các đỉnh không có bất kỳ cạnh nào nối giữa chúng. Mục tiêu là tối đa hóa kích thước của tập độc lập này. Đây là bài toán NP-hard và thường được giải quyết bằng các thuật toán gần đúng hoặc thuật toán tìm kiếm theo chiều rộng hoặc chiều sâu trong đồ thị.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm tập độc lập lớn nhất trong đồ thị (Maximal Independent Set)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 198
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "minimumcostmaximumflow",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu giải quyết bài toán dòng chảy cực đại với chi phí tối thiểu trong một mạng lưới. Bạn cần tìm dòng chảy cực đại từ một nguồn đến một đích sao cho tổng chi phí dòng chảy là nhỏ nhất. Để giải bài toán này, bạn cần sử dụng thuật toán tìm kiếm cực đại và chi phí tối thiểu, như thuật toán Edmonds-Karp hoặc thuật toán thuật toán Dinic với điều kiện chi phí.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Dòng chảy cực đại với chi phí tối thiểu (Minimum Cost Maximum Flow)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 199
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "travellingalgorithms",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu bạn giải quyết một biến thể của bài toán du lịch salesman (Travelling Salesman Problem), trong đó bạn phải tìm đường đi ngắn nhất qua các thành phố với một số yếu tố thêm vào, chẳng hạn như một số thành phố phải được thăm trước hoặc sau các thành phố khác, hoặc cần phải đi qua các điểm cụ thể. Bài toán này yêu cầu sử dụng các thuật toán tối ưu hóa và các phương pháp tìm kiếm như nhánh cắt hoặc thuật toán di truyền.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Biến thể của bài toán du lịch salesman (Travelling Algorithms)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 200
      }
      ,
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "dynamicoptimizationrobotics",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tối ưu hóa quỹ đạo chuyển động của robot trong một không gian 2D hoặc 3D. Mục tiêu là tìm đường đi ngắn nhất cho robot với các rào cản trong môi trường, đồng thời tối ưu hóa thời gian hoặc năng lượng tiêu thụ. Bài toán này liên quan đến các thuật toán tìm kiếm như A* hoặc thuật toán Dijkstra, và các phương pháp tối ưu hóa như quy hoạch động hoặc phương pháp tìm kiếm cục bộ.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tối ưu hóa quỹ đạo robot (Dynamic Optimization in Robotics)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 201
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "stochasticoptimizationgame",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán này yêu cầu tối ưu hóa chiến lược trong một trò chơi ngẫu nhiên. Người chơi phải lựa chọn các hành động sao cho tối đa hóa điểm số trong khi đối mặt với các yếu tố ngẫu nhiên, như xác suất chiến thắng, sự thay đổi ngẫu nhiên của điểm số, hoặc sự tác động của đối thủ. Bài toán này liên quan đến các thuật toán tối ưu hóa ngẫu nhiên và lý thuyết trò chơi, bao gồm các chiến lược tối ưu và phương pháp Monte Carlo.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tối ưu hóa chiến lược trong trò chơi ngẫu nhiên (Stochastic Optimization in Games)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 202
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "geneticprogrammingoptimization",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tối ưu hóa thông qua lập trình di truyền (genetic programming). Bạn sẽ sử dụng các phép toán di truyền như đột biến, lai ghép và chọn lọc để tối ưu hóa một hàm mục tiêu trong không gian tìm kiếm. Bài toán có thể áp dụng cho các bài toán tìm kiếm hàm tối ưu, phát triển thuật toán tự động hoặc tối ưu hóa các mô hình học máy.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tối ưu hóa qua lập trình di truyền (Genetic Programming Optimization)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 203
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "maximummatchingsubgraph",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm một cách ghép tối đa các đỉnh trong một đồ thị con sao cho số lượng các cạnh kết nối giữa các đỉnh là tối đa. Đồ thị con này phải thoả mãn một số điều kiện nhất định, chẳng hạn như không có chu trình lạ hay các cạnh bị trùng lặp. Bài toán này có thể được giải quyết bằng cách áp dụng các thuật toán ghép đôi như thuật toán Kuhn-Munkres hoặc các phương pháp dòng chảy cực đại.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm ghép tối đa trong đồ thị con (Maximum Matching in a Subgraph)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 204
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "realtimealgorithmscheduling",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu bạn lập kế hoạch lịch trình các tác vụ trong môi trường thời gian thực, sao cho tất cả các tác vụ đều hoàn thành đúng hạn và không có sự trễ. Các tác vụ này có thể có độ ưu tiên khác nhau và phải được phân bổ một cách hợp lý vào các tài nguyên sẵn có. Bạn sẽ cần sử dụng các thuật toán lên lịch như tối ưu hóa tài nguyên hoặc thuật toán duyệt lịch trình cắt theo thời gian.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Lập kế hoạch lịch trình thời gian thực (Real-time Algorithm Scheduling)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 205
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "intervalgraphcoloring",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tô màu các đỉnh trong đồ thị theo cách sao cho không có hai đỉnh nối với nhau có cùng màu. Đồ thị là đồ thị khoảng thời gian, tức là mỗi đỉnh đại diện cho một khoảng thời gian, và một cạnh giữa hai đỉnh biểu thị sự chồng lấn giữa hai khoảng thời gian đó. Mục tiêu là sử dụng số lượng màu tối thiểu để tô màu các đỉnh sao cho không có hai khoảng thời gian chồng lấn cùng một màu.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tô màu đồ thị khoảng thời gian (Interval Graph Coloring)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 206
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "maximumflowwithcost",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu giải quyết vấn đề dòng chảy cực đại trong một mạng lưới có chi phí. Bạn cần tìm dòng chảy cực đại từ nguồn đến đích sao cho tổng chi phí của dòng chảy là tối thiểu. Mỗi cạnh trong đồ thị có một khả năng và chi phí riêng. Bài toán này có thể được giải quyết bằng cách sử dụng thuật toán Ford-Fulkerson kết hợp với các kỹ thuật tìm kiếm chiều rộng (BFS) hoặc chiều sâu (DFS) để tìm kiếm dòng chảy hợp lý trong mạng có chi phí.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Dòng chảy cực đại với chi phí (Maximum Flow with Cost)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 207
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "vertexcoverminimization",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm tập hợp các đỉnh trong đồ thị sao cho mỗi cạnh đều có ít nhất một đầu mút thuộc tập hợp này. Tập hợp các đỉnh này phải có số lượng ít nhất có thể. Bài toán này thuộc lớp NP-đầy đủ và có thể được giải quyết gần đúng bằng các thuật toán tham lam hoặc bằng phương pháp tối ưu hóa.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tối thiểu hóa tập đỉnh bao phủ (Vertex Cover Minimization)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 208
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "multidimensionaldpoptimization",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tối ưu hóa một bài toán quy hoạch động nhiều chiều, trong đó các quyết định tối ưu không chỉ phụ thuộc vào một chiều mà còn phụ thuộc vào nhiều chiều khác nhau. Bạn sẽ cần phải áp dụng các kỹ thuật quy hoạch động mở rộng và tối ưu hóa để giải quyết bài toán. Ví dụ, bài toán này có thể được áp dụng trong các bài toán tối ưu hóa đa mục tiêu, quản lý nguồn lực, hoặc phân bổ tài nguyên trong các hệ thống phức tạp.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tối ưu hóa quy hoạch động nhiều chiều (Multidimensional DP Optimization)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 209
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "maximalindependentset1",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm tập con độc lập tối đa trong một đồ thị. Một tập con độc lập là tập hợp các đỉnh mà không có hai đỉnh nào nối với nhau bằng một cạnh. Mục tiêu của bài toán là tìm ra tập con độc lập có số lượng đỉnh lớn nhất trong đồ thị cho trước. Bài toán này là một bài toán NP-đầy đủ và có thể được giải quyết bằng các thuật toán xấp xỉ hoặc thuật toán phân tách đồ thị.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tập con độc lập tối đa - nâng cao",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 210
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "longestpathinweightedgraph",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm đường đi dài nhất trong đồ thị có trọng số, từ một đỉnh nguồn đến một đỉnh đích. Trong đồ thị có trọng số, đường đi dài nhất là một đường đi sao cho tổng trọng số các cạnh trên đường đi này là lớn nhất. Bài toán này có thể được giải quyết bằng cách sử dụng thuật toán Dijkstra điều chỉnh hoặc áp dụng phương pháp duyệt đồ thị theo chiều rộng hoặc chiều sâu.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Đường đi dài nhất trong đồ thị có trọng số (Longest Path in Weighted Graph)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 211
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "perfectmatchinggraph",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm ghép hoàn hảo trong đồ thị. Ghép hoàn hảo là một tập hợp các cạnh sao cho mỗi đỉnh của đồ thị đều xuất hiện trong một và chỉ một cạnh của tập hợp này. Mục tiêu là tìm một ghép hoàn hảo có thể trong đồ thị đã cho, hoặc xác định rằng không thể tìm được ghép hoàn hảo nếu có đỉnh lẻ hoặc các điều kiện khác không thỏa mãn.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Ghép hoàn hảo trong đồ thị (Perfect Matching in Graph)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 212
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "stronglyconnectedcomponents1",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm các thành phần liên thông mạnh trong một đồ thị có hướng. Thành phần liên thông mạnh là một tập các đỉnh sao cho mỗi đỉnh trong tập có thể đến được các đỉnh còn lại trong cùng tập đó. Bài toán này có thể được giải quyết bằng thuật toán Tarjan hoặc Kosaraju, hai thuật toán phổ biến để tìm các thành phần liên thông mạnh trong đồ thị có hướng.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Thành phần liên thông mạnh trong đồ thị có hướng (Strongly Connected Components)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 213
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "mincostmaxflow",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm dòng chảy tối thiểu trong một mạng lưới có chi phí. Dòng chảy tối thiểu là dòng chảy sao cho tổng chi phí của dòng chảy là nhỏ nhất, với mỗi cạnh có một chi phí và một khả năng. Bài toán này có thể được giải quyết bằng thuật toán Min-Cost Max-Flow, kết hợp giữa thuật toán Ford-Fulkerson và thuật toán tìm kiếm đường đi ngắn nhất trong đồ thị có trọng số.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Dòng chảy tối thiểu trong mạng có chi phí (Min-Cost Max Flow)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 214
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "maximumclique",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm một k-đỉnh tối đa trong đồ thị, tức là tìm một tập con các đỉnh sao cho giữa bất kỳ hai đỉnh nào trong tập này đều có một cạnh nối. Bài toán này có thể được giải quyết bằng các thuật toán tìm kiếm hoặc các thuật toán xấp xỉ cho phép tìm ra tập con đỉnh lớn nhất thỏa mãn điều kiện trên.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tập đỉnh lớn nhất trong đồ thị (Maximum Clique)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 215
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "graphcolorin4g",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm cách tô màu các đỉnh của đồ thị sao cho không có hai đỉnh nào kề nhau có cùng màu. Số màu sử dụng cần phải tối thiểu. Đây là một bài toán NP-đầy đủ và có thể giải quyết bằng các thuật toán xấp xỉ hoặc sử dụng các kỹ thuật tìm kiếm như backtracking hoặc thuật toán Greedy.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tô màu đồ thị - nâng cao",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 216
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "knapsackproblem",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm ra cách chọn các vật phẩm sao cho tổng giá trị của các vật phẩm chọn được là tối đa, nhưng tổng trọng lượng không vượt quá một giới hạn cho trước. Đây là một bài toán NP-đầy đủ và có thể giải quyết bằng phương pháp động, đặc biệt là thuật toán động cho bài toán balo (knapsack).",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Bài toán cái balo (Knapsack Problem)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 217
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "travellingsalesman",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán người bán hàng (Traveling Salesman Problem) yêu cầu tìm một đường đi ngắn nhất sao cho người bán hàng có thể đi qua tất cả các thành phố mà không quay lại thành phố nào, và quay lại điểm xuất phát. Đây là một bài toán NP-đầy đủ, và có thể giải quyết bằng các thuật toán xấp xỉ như thuật toán Quân đội hoặc sử dụng phương pháp chiết giảm chi phí.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Bài toán người bán hàng (Travelling Salesman Problem)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 218
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "subgraphisomorphism",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm xem một đồ thị con có phải là đồng nhất với một đồ thị mẫu hay không, tức là kiểm tra xem đồ thị mẫu có thể xuất hiện trong đồ thị cho trước hay không. Đây là một bài toán NP-đầy đủ, và có thể giải quyết bằng thuật toán tìm kiếm cây hay phương pháp quay lui (backtracking).",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Kiểm tra đồng nhất đồ thị con (Subgraph Isomorphism)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 219
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "minimumspanningtree",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm cây bao trùm nhỏ nhất trong một đồ thị có trọng số. Cây bao trùm nhỏ nhất là cây con của đồ thị có trọng số sao cho tất cả các đỉnh của đồ thị đều có mặt trong cây đó và tổng trọng số các cạnh là nhỏ nhất. Bài toán này có thể giải quyết bằng các thuật toán như Kruskal hoặc Prim.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Cây bao trùm nhỏ nhất (Minimum Spanning Tree)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 220
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "networkflow1",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm dòng chảy tối đa từ một đỉnh nguồn đến một đỉnh đích trong mạng có dòng chảy. Mỗi cạnh trong mạng có một khả năng nhất định và bài toán yêu cầu xác định dòng chảy tối đa có thể truyền từ nguồn đến đích mà không vượt quá khả năng của các cạnh. Thuật toán Ford-Fulkerson hoặc Edmonds-Karp có thể được sử dụng để giải quyết bài toán này.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Dòng chảy tối đa trong mạng (Maximum Flow) - cải tiến",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 221
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "longestpath3",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm đường đi dài nhất trong một đồ thị có trọng số, không quay lại các đỉnh đã đi qua. Đường đi dài nhất có thể không tồn tại trong mọi đồ thị, và bài toán này có thể giải quyết bằng thuật toán tìm kiếm theo chiều sâu (DFS) kết hợp với quy hoạch động (dynamic programming) trong các đồ thị có chu trình vô hướng hoặc thuật toán Bellman-Ford trong đồ thị có chu trình.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm đường đi dài nhất trong đồ thị (Longest Path)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 222
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "maxsubarray",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm dãy con có tổng lớn nhất trong một dãy số cho trước. Dãy con này phải liên tiếp và có tổng các phần tử là lớn nhất có thể. Đây là bài toán có thể giải quyết bằng thuật toán Kadane, một thuật toán tuyến tính rất hiệu quả để giải quyết bài toán này.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm dãy con có tổng lớn nhất (Maximum Subarray)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 223
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "dijkstrashortestpath1",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm đường đi ngắn nhất từ một đỉnh đến tất cả các đỉnh còn lại trong đồ thị có trọng số không âm. Đây là bài toán cổ điển có thể giải quyết bằng thuật toán Dijkstra, một thuật toán sử dụng cấu trúc dữ liệu heap để tìm đường đi ngắn nhất một cách hiệu quả.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm đường đi ngắn nhất - cải tiến",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 224
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "stronglyconnectedcomponents",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm tất cả các thành phần liên thông mạnh trong đồ thị có hướng. Một thành phần liên thông mạnh là một tập hợp các đỉnh sao cho mỗi đỉnh có thể đi đến bất kỳ đỉnh nào khác trong thành phần đó thông qua các cạnh có hướng. Bài toán này có thể giải quyết bằng thuật toán Kosaraju hoặc Tarjan.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm thành phần liên thông mạnh trong đồ thị có hướng (Strongly Connected Components)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 225
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "topologicalsort",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu sắp xếp các đỉnh của đồ thị có hướng sao cho với mỗi cạnh (u, v) trong đồ thị, đỉnh u xuất hiện trước đỉnh v trong dãy sắp xếp. Đây là bài toán quan trọng trong lý thuyết đồ thị, có thể giải quyết bằng thuật toán DFS hoặc thuật toán Kahn.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Sắp xếp topo trong đồ thị có hướng (Topological Sort)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 226
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "matrixchainmultiplication",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm cách nhân ma trận một cách hiệu quả nhất, sao cho số phép toán thực hiện là tối thiểu. Bài toán này có thể được giải quyết bằng phương pháp động, trong đó ta tối ưu hóa thứ tự nhân các ma trận để giảm thiểu chi phí tính toán.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Nhân ma trận chuỗi (Matrix Chain Multiplication)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 227
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "knapsackproblem3",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán balo yêu cầu tìm cách chọn một tập hợp đồ vật sao cho tổng giá trị của các đồ vật đó là lớn nhất và tổng khối lượng không vượt quá sức chứa của ba lô. Đây là một bài toán quy hoạch động có thể giải quyết bằng cách sử dụng bảng để lưu trữ các giá trị tối ưu.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Bài toán balo - nâng cao",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 228
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "editdistance",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán khoảng cách chỉnh sửa yêu cầu tìm số lượng thao tác tối thiểu cần thiết để biến một chuỗi thành một chuỗi khác, với các thao tác bao gồm thay thế, chèn hoặc xóa ký tự. Đây là một bài toán quy hoạch động phổ biến và có thể giải quyết bằng bảng DP.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Khoảng cách chỉnh sửa (Edit Distance)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 229
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "longestcommonsubsequence",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán tìm dãy con chung dài nhất yêu cầu tìm dãy con dài nhất xuất hiện trong cả hai chuỗi cho trước. Đây là một bài toán quy hoạch động phổ biến và có thể giải quyết bằng cách xây dựng bảng DP để lưu trữ kết quả tìm thấy cho mỗi cặp chỉ số trong hai chuỗi.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Dãy con chung dài nhất (Longest Common Subsequence)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 230
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "binarysearch",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu áp dụng thuật toán tìm kiếm nhị phân (binary search) để tìm kiếm một giá trị trong dãy số đã được sắp xếp. Tìm kiếm nhị phân là một phương pháp hiệu quả với độ phức tạp O(log n), được sử dụng rộng rãi trong các bài toán tìm kiếm trên dãy số hoặc các cấu trúc dữ liệu phân cấp.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Tìm kiếm nhị phân (Binary Search)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 231
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "fibonacci",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tính số Fibonacci thứ n. Số Fibonacci là dãy số mà mỗi số là tổng của hai số liền kề trước đó, bắt đầu với 0 và 1. Dãy số Fibonacci có thể tính bằng phương pháp đệ quy hoặc thông qua quy hoạch động để tối ưu hóa thời gian tính toán.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Số Fibonacci (Fibonacci Sequence)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 232
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "primefactors",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm các ước số nguyên tố của một số nguyên n. Sử dụng phương pháp phân tích số nguyên thành các thừa số nguyên tố là một vấn đề cổ điển trong lý thuyết số và có thể thực hiện bằng cách thử chia n với các số nguyên tố nhỏ hơn căn bậc hai của n.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Ước số nguyên tố (Prime Factors)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 233
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "matrixmultiplication3",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu nhân hai ma trận. Ma trận đầu tiên có kích thước m x n và ma trận thứ hai có kích thước n x p. Kết quả là một ma trận m x p. Phương pháp nhân ma trận có thể thực hiện bằng cách tính tích từng phần tử của dòng ma trận đầu tiên và cột ma trận thứ hai.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Nhân ma trận - bản mới",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 234
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "countingprimes",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu đếm số lượng số nguyên tố trong khoảng từ 1 đến n. Một số nguyên tố là một số chỉ có thể chia hết cho 1 và chính nó. Để giải quyết bài toán này, ta có thể sử dụng thuật toán Sieve of Eratosthenes để tìm các số nguyên tố trong khoảng này một cách hiệu quả.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Đếm số nguyên tố (Counting Primes)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 235
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "shortestpathdijkstra",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm đường đi ngắn nhất từ một đỉnh đến tất cả các đỉnh còn lại trong đồ thị có trọng số. Thuật toán Dijkstra là một thuật toán hiệu quả để giải quyết bài toán này, sử dụng một hàng đợi ưu tiên để chọn đỉnh có trọng số nhỏ nhất ở mỗi bước.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Đường đi ngắn nhất với Dijkstra (Shortest Path - Dijkstra)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 236
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "longestpath1",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm đường đi dài nhất trong đồ thị có trọng số. Khác với thuật toán Dijkstra tìm đường đi ngắn nhất, bài toán này yêu cầu tìm đường đi dài nhất trong đồ thị, có thể sử dụng thuật toán DFS hoặc thuật toán Bellman-Ford cho đồ thị có trọng số âm.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Đường đi dài nhất - cải tiến",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 237
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "findsubarray",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tìm dãy con liên tiếp có tổng lớn nhất trong mảng. Đây là một bài toán cổ điển trong kỹ thuật lập trình động, có thể giải quyết bằng cách sử dụng thuật toán Kadane, cho phép tìm dãy con liên tiếp có tổng lớn nhất trong thời gian O(n).",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Dãy con liên tiếp có tổng lớn nhất (Maximum Subarray)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 238
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "balancedparentheses",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu kiểm tra xem chuỗi có chứa dấu ngoặc có cân bằng hay không. Để chuỗi có dấu ngoặc cân bằng, mỗi dấu ngoặc mở phải có một dấu ngoặc đóng tương ứng. Bài toán này có thể giải quyết bằng cách sử dụng ngăn xếp (stack).",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Kiểm tra dấu ngoặc cân bằng (Balanced Parentheses)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 239
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "toposort",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu thực hiện sắp xếp topo cho một đồ thị có hướng. Sắp xếp topo là một cách sắp xếp các đỉnh của đồ thị sao cho đối với mỗi cạnh (u, v), đỉnh u xuất hiện trước đỉnh v trong thứ tự sắp xếp. Để giải quyết bài toán này, có thể sử dụng thuật toán DFS hoặc thuật toán Kahn.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Sắp xếp topo (Topological Sort)",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 240
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "knapsackproblem5",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu giải quyết bài toán balo (Knapsack Problem), trong đó bạn cần tối đa hóa giá trị của các món đồ được chọn sao cho tổng trọng lượng không vượt quá giới hạn cho phép. Bài toán này có thể giải quyết bằng phương pháp quy hoạch động hoặc thuật toán tham lam.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Bài toán balo 2",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 241
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "graphcoloring5",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bài toán yêu cầu tô màu cho các đỉnh của đồ thị sao cho không có hai đỉnh kề nhau cùng màu. Số lượng màu tối thiểu cần dùng để tô màu đồ thị này là số mầu sắc tối thiểu của đồ thị. Bài toán này có thể giải quyết bằng cách sử dụng thuật toán tham lam hoặc thuật toán tìm kiếm theo chiều sâu.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "Bảng tô màu đồ thị",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 242
      }   ,
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "median",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Bạn được cho một dãy số nguyên dương không giảm và truy vấn, với mỗi truy vấn bạn được yêu cầu in ra phần tử trung vị của dãy hiện tại và loại bỏ nó khỏi dãy (nếu dãy có số theo thứ tự không giảm thì số trung vị là số thứ ).\n\n## Input Specification\n\nThe first line will contain two integers ~N~ and ~M~ (~1 \\le N, M \\le 300~), representing the number of rows and columns in the grid. Each of the next ~N~ lines contains ~M~ characters ('1' or '0').\n\n## Output Specification\n\nOutput a single integer, the number of islands.\n\n## Sample Input\n\n    4 5\n    11000\n    11000\n    00100\n    00011\n\n## Sample Output\n\n    3",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "MEDIAN - Truy vấn trung vị",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 243
      }   ,
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "HFAMOUS",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Công ty ABC chuyên thu thập thông tin về những người nổi tiếng. Trong hồ sơ của công ty có \nngười nổi tiếng được đánh số từ \nđến \n. Hồ sơ này chứa thông tin về \nmối quan hệ, mỗi mối quan hệ được biểu diễn bằng hai số nguyên \ncho biết rằng người nổi tiếng \nquen với người nổi tiếng \nvà ngược lại.\n\nĐể tổ chức chương trình \"Khai giảng\" thật hoành tráng, trường THPT Chuyên Sơn La muốn mời một số người nổi tiếng trong danh sách của công ty ABC sao cho trong số những người được mời, người nào cũng quen với ít nhất \nngười khác và số lượng người được mời phải là nhiều nhất.\n\n## Sample Input\n\n    4 5\n    11000\n    11000\n    00100\n    00011\n\n## Sample Output\n\n    3",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "HFAMOUS - Người nổi tiếng",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 244
      }   ,
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "WOODCUT",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Một người nông dân muốn cắt một thanh gỗ có độ dài \ncủa mình thành \nmiếng, mỗi miếng có độ dài là một số nguyên dương \n. Tuy nhiên để cắt một miếng gỗ có độ dài là \nthành hai phần thì ông ta sẽ mất \ntiền. Ông nông dân này không giỏi tính toán lắm, vì vậy bạn được yêu cầu lập trình giúp cho ông ta biết cần để dành ít nhất bao nhiêu tiền thì mới có thể cắt được những tấm gỗ như mong muốn.\n\n## Sample Input\n\n    4 5\n    11000\n    11000\n    00100\n    00011\n\n## Sample Output\n\n    3",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "WOODCUT - Cắt gỗ",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 245
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "XORNARY",
          "curators": [],
          "date": "2024-12-20T05:00:00Z",
          "description": "Cho 2 dãy nhị phân \nvà \n. Hãy thực hiện phép \n(phép \ntương đương với toán tử ^ trong một số các ngôn ngữ lập trình) và in ra kết quả của phép \nđó.\n\n## Sample Input\n\n    4 5\n    11000\n    11000\n    00100\n    00011\n\n## Sample Output\n\n    3",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "XORNARY - Phép XOR trên dãy nhị phân",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 246
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "dicay",
          "curators": [],
          "date": "2024-12-21T05:00:00Z",
          "description": "Nghé con hôm nay đi tham gia cuộc thi do làng tổ chức. Bài thi của Nghé là cày n thửa ruộng (đánh số từ 1 đến n). Để cày thửa ruộng thứ i Nghé cần thời gian là ti và nếu cày xong sẽ được số điểm là di. Tuy nhiên, Nghé chỉ có tổng thời gian là S để “làm bài”, do vậy Nghé cần lựa chọn những thửa ruộng để cày cho hợp lý. Bạn hãy lập chương trình giúp Nghé lựa chọn các thửa ruộng để cày trong thời gian S sao cho đạt điểm tối đa.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "DICAY - Nghé đi cày",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 247
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "egroup",
          "curators": [],
          "date": "2024-12-21T05:00:00Z",
          "description": "Chỉ dẫn hàng ngày của nông dân John ghi rất rõ ràng: “Trước khi dùng bữa tối, đàn bò cần xếp thành một hàng dọc. Những con cầm tấm thẻ số nhỏ hơn luôn đứng trước những con cầm tấm thẻ số lớn hơn”. Tuy nhiên, đàn bò của nông dân John lại gây náo loạn và đứng sai vị trí. Có tất cả n con bò, con bò thứ i (từ đầu hàng trở xuống) hiện đang cầm tấm thẻ ai. Tuy nhiên, nông dân John không quá khắt khe về chuyện phạt lũ bò. Anh quyết định sửa lại giá trị trên một số tấm thẻ sao cho điều luật trên được thỏa mãn (sau khi sửa, có thể sẽ không còn tấm thẻ số nhỏ nhất hoặc lớn nhất nào). Hãy giúp nông dân John sửa ít tấm thẻ nhất mà vẫn đảm bảo điều luật. Anh không thể đổi chỗ các con bò cho nhau (các con bò có kích thước quá lớn để có thể làm việc đó).\n\nInput: \nDòng đầu chứa số nguyên dương n; dòng sau, dòng thứ i chứa số nguyên dương ai.\n\nOutput: \nMột số nguyên duy nhất là số lần sửa tối thiểu.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "EGROUP - Đàn bò của nông dân John",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 248
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "gameshow",
          "curators": [],
          "date": "2024-12-21T05:00:00Z",
          "description": "Taii tham gia một trò chơi hách não. Để bắt đầu anh ta phải chọn được chính xác ô cửa bắt đầu của mình. Trọng tài phát cho mỗi người một mảnh giấy trong đó có ghi mật mã chính là số của ô cửa mà anh ta phải bắt đầu. Tuy nhiên, Taii đã chọn quyền trợ giúp của người thân để giúp anh vượt qua câu hỏi đầu tiên. Bạn sẽ giúp Taii tìm số ô cửa bắt đầu theo mật mã có sẵn trên mảnh giấy. Nếu không thể tìm được mật mã hợp lệ, hãy in ra thông báo kết thúc.",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "GAMESHOW - Ai là triệu phú",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 250
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "maze",
          "curators": [],
          "date": "2024-12-21T05:00:00Z",
          "description": "Long đang trên đường đi học thì không may bị một kẻ xấu bắt nhốt vào trong một mê cung. Mê cung gồm n căn phòng xếp nối tiếp nhau theo thứ tự phòng 1, phòng 2, ..., phòng n. Long hiện đang ở phòng 1, và lối thoát ở phòng n. Giữa n căn phòng có n-1 cánh cửa. Ban đầu tại thời điểm 0, tất cả các cánh cửa đều đóng. Sau đó, cánh cửa thứ i sẽ chỉ mở ra mỗi giây. Long bắt đầu di chuyển tại phòng 1 từ thời điểm 0. Câu hỏi đặt ra cho bạn là hãy tìm thời điểm sớm nhất mà Long sẽ thoát khỏi mê cung.",
          "group": 3,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "MAZE - Thoát khỏi mê cung",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 251
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "coingame",
          "curators": [],
          "date": "2024-12-21T05:00:00Z",
          "description": "Alice và Bob chơi trò bốc xu từ một đống có n đồng xu. Hai người chọn hai số nguyên dương khác nhau x và y. Hai người lần lượt đi, Alice đi trước. Mỗi người, khi đến lượt mình, được bốc từ đống đó x hoặc y xu (Nếu không còn đủ x hoặc y đồng xu thì chỉ được bốc đồng). Ai bốc được đồng xu (hoặc các đồng xu) cuối cùng là thắng. Alice muốn biết liệu cô có thắng được hay không nếu cả hai chơi tối ưu.",
          "group": 4,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "COINGAME - Trò chơi với những đồng xu",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 252
      },
      {
        "fields": {
          "ac_rate": 0.0,
          "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
          "authors": [1],
          "banned_users": [],
          "code": "ances",
          "curators": [],
          "date": "2024-12-21T05:00:00Z",
          "description": "Các nút được đánh số từ 1 đến n. Nút 1 là gốc. Nút i được gọi là nút cha của j, nếu tồn tại một đường dẫn từ gốc tới j đi qua i. Nút cha chung của hai nút u và v là nút mà cả u và v đều có thể đi qua khi từ gốc đến u và v. Nút cha chung gần nhất là nút cha chung của u và v, trên đường dẫn từ u tới v không còn nút cha chung nào khác của cả hai.",
          "group": 6,
          "is_manually_managed": false,
          "is_public": true,
          "license": null,
          "memory_limit": 65536,
          "name": "ANCES - Nút cha chung gần nhất",
          "og_image": "",
          "partial": true,
          "points": 50.0,
          "short_circuit": false,
          "summary": "",
          "testers": [],
          "time_limit": 5.0,
          "types": [11, 16],
          "user_count": 0
        },
        "model": "judge.problem",
        "pk": 253
      }
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "kangaroo",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Trên chiều dương của trục tọa độ Ox, có hai chú Kangaroo Kangaroo 1 và Kangaroo 2. Kangaroo 1 ở điểm có tọa độ x1, nhảy được v1 mét sau mỗi lần nhảy. Kangaroo 2 ở điểm có tọa độ x2, nhảy được v2 mét sau mỗi lần nhảy. Yêu cầu: trả lời câu hỏi xem hai chú Kangaroo có thể cùng đến một vị trí trong cùng một thời điểm hay không.",
    "group": 3,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "KANGAROO - Bước nhảy KANGAROO",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 254
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "angry",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Lớp học Toán rời rạc của CTP IT có n học sinh. Giáo sư Hải Dương sẽ hủy buổi học nếu khi bắt đầu vào giờ học mà có ít hơn k học sinh có mặt đúng giờ. Hãy xác định liệu buổi học có bị hủy hay không.",
    "group": 2,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "ANGRY - Giáo sư nổi giận",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 255
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "tickets",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "HD cần mua n chiếc vé xe bus, mỗi chiếc vé có giá c VNĐ. Tuy nhiên, HD biết có một gói khuyến mại là mua k vé chỉ mất p VNĐ. Yêu cầu: tính xem HD sẽ mất ít nhất bao nhiêu tiền để mua đủ n vé xe bus.",
    "group": 2,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "TICKETS - Mua vé xe buýt",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 256
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "icecream",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Máy bán kem tự động bán mỗi que kem với giá a, chấp nhận các đồng xu mệnh giá x1, x2, x3. Máy ban đầu có một số lượng đồng xu nhất định, và sẽ trả lại tiền thối cho học sinh nếu có đủ đồng xu. Nhiệm vụ của thầy giáo là phát cho mỗi học sinh một đồng xu để mua một que kem. Cần đếm xem thầy giáo có bao nhiêu cách phát tiền cho học sinh sao cho hợp lệ.",
    "group": 2,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "ICECREAM - Máy bán kem tự động",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 257
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "lands",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Vương quốc có hình dạng là một khu vực hình chữ nhật với m hàng và n cột. Một số tỉnh đã bị chiếm đóng. Nhiệm vụ của bạn là tính số cách chọn các tỉnh còn lại sao cho sau khi chiếm xong các tỉnh đó, các tỉnh đã chiếm tạo thành một hình chữ nhật, và số lần chiếm là nhiều nhất. Bạn cần in ra kết quả này modulo một số rất lớn.",
    "group": 3,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "LANDS - Xâm chiếm lãnh thổ",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 258
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "mowlawn",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Nông dân John cần dọn dẹp khu vườn nhưng chỉ có thể chọn một số con bò để giúp đỡ, với điều kiện không được chọn quá k bò liên tiếp. Mỗi con bò có một độ hiệu quả nhất định. Nhiệm vụ của bạn là giúp John chọn những con bò sao cho tổng độ hiệu quả của chúng là lớn nhất và không vi phạm điều kiện trên.",
    "group": 3,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "MOWLAWN - Dọn dẹp khu vườn",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 259
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "penguins",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Tại Nam Cực, các tảng băng là nơi sinh sống của các con chim cánh cụt. Để tổ chức một buổi liên hoan, các chim cánh cụt cần chọn tảng băng nào đó làm nơi tổ chức. Tảng băng sẽ chìm nếu chiều cao của nó giảm xuống 0 do các chim cánh cụt nhảy qua các tảng băng khác. Hãy tính xem có tảng băng nào có thể tổ chức liên hoan không, dựa trên khả năng nhảy của chim cánh cụt và sự thay đổi độ cao của tảng băng.",
    "group": 3,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "PENGUINS - Chim cánh cụt",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 260
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "vacation",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Kỳ nghỉ hè của Kaninho bắt đầu vào ngày mai, và anh ấy quyết định lên kế hoạch ngay từ bây giờ. Trong kỳ nghỉ gồm N ngày, Kaninho có thể chọn một trong ba hoạt động sau mỗi ngày: Đi bơi ở biển, đi bắt sâu bọ ở trên núi, hoặc làm bài tập về nhà. Mỗi hoạt động mang lại một mức độ 'hạnh phúc' nhất định cho Kaninho. Tuy nhiên, anh ấy không thể thực hiện cùng một hoạt động trong hai ngày liên tiếp. Hãy tính toán độ hạnh phúc lớn nhất mà Kaninho có thể đạt được trong kỳ nghỉ của mình. \n\n## Input Specification\n\n\n\n## Output Specification\n\nOutput \n\n## Sample Input\n\n    \n\n## Sample Output\n\n    ",
    "group": 3,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "VACATION - Kì nghỉ của Kaninho",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 261
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "LBC_3B",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Dr. Patel is playing a game with his daughter to celebrate her birthday. The game proceeds as follows:\n\nStarting with Dr. Patel, he chooses a number N and checks if there exists a number M such that N is divisible by M. If not, he decreases N using the operation N - M until M and N are the largest possible. The game continues until one player performs one of these operations and results in 0, making that player the winner.\n\nYour task is to determine if Dr. Patel can win the game based on the given N.\n\n## Input Specification\n\nThe first line contains an integer T, the number of test cases. The next T lines contain one integer N each.\n\n## Output Specification\n\nFor each test case, output 'yes' if Dr. Patel can win, otherwise output 'no'.\n\n## Sample Input\n\n3\n10\n15\n20\n\n## Sample Output\n\nyes\nno\nyes",
    "group": 4,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "LBC_3B - Dr. Patel và sinh nhật con gái",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 262
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "LBC_2F",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Phát is completing his final exam and has encountered a problem involving a rotating wheel of 3 integers and a prime number. The wheel undergoes multiple rotations, and before each rotation, Phát calculates a result using a mathematical operation, then takes the modulus of the result by a given prime number. After each rotation, the positions of the integers are swapped, and the process continues until all rotations are completed.\n\nThe task is to answer multiple queries where, for each query, you are asked to find the sum of results for rotations within a specified range.\n\n## Input Specification\n\nThe first line contains two integers N and P, where N is the number of rotations, and P is a prime number. The second line contains 3 integers, the values on the wheel. The following lines contain pairs of integers, each representing a query with two integers L and R. For each query, you need to calculate the sum of results for rotations from L to R.\n\n## Output Specification\n\nFor each query, output the sum of results for the specified range of rotations.\n\n## Sample Input\n\n5 3\n1 2 3\n1 3\n2 4\n\n## Sample Output\n\n6\n9",
    "group": 4,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "LBC_2F - Mũ cực mạnh",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 263
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "LC3A",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Barbara is a very fast typist. To determine her typing speed, she took a test where she was given a string S that she needed to type. However, while typing, she made some mistakes and continued typing without fixing them. After completing the typing test, Barbara formed a string T. Now, she wants to know how many characters she needs to delete from T to obtain string S. It's also possible that Barbara made too many errors or missed some characters, and it may not be possible to form S from T.\n\nThe task is to find out how many characters need to be deleted to transform T into S, or if it is impossible to do so.\n\n## Input Specification\n\nThe first line contains an integer Q, the number of queries.\nFor each query, there are two strings. The first string is S, the required string, and the second string is T, the string typed by Barbara.\n\n## Output Specification\n\nFor each query, output the result in the format:\nCase #x: y\nWhere x is the query number (starting from 1) and y is the number of deletions required to form string S from T. If it's impossible, output IMPOSSIBLE.\n\n## Sample Input\n\n2\nabc\nabdc\nab\nabcd\n\n## Sample Output\n\nCase #1: 1\nCase #2: 0",
    "group": 4,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "LC3A - Đánh máy nhanh",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 264
},
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "FSEGMENT",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Trên một hệ trục tọa độ Ox, có N đoạn thẳng. Các đoạn thẳng được đánh số từ 1 đến N. Đoạn thẳng thứ i có đầu mút bên trái tại Li và đầu mút bên phải tại Ri.Ta nói rằng, một điểm có tọa độ x được phủ bởi đoạn thẳng i khi và chỉ khi x nằm giữa hai đầu mút của i (tức là Li ≤ x ≤ Ri).Có Q truy vấn, mỗi truy vấn được mô tả bởi hai số nguyên a và b, yêu cầu:\n\n• Trong số N đoạn thẳng đã cho, cần chọn ra một số đoạn thẳng, sao cho tất cả các điểm có tọa độ từ a đến b đều được bao phủ bởi ít nhất một đoạn thẳng trong các đoạn thẳng được lựa chọn. Hãy in ra số lượng đoạn thẳng ít nhất cần lựa chọn.\n\nYêu cầu: Viết chương trình trả lời Q truy vấn trên.\n\n## Input Specification\n\n• Dòng đầu tiên gồm số nguyên N (1 ≤ N ≤ 200000) - số đoạn thẳng.\n\n• N dòng tiếp theo, dòng thứ i gồm hai số nguyên Li và Ri ( ) - tọa độ hai đầu mút của đoạn thẳng thứ i.\n\n• Dòng tiếp theo gồm số nguyên Q (1 ≤ Q ≤ 200000) - số truy vấn cần xử lí.\n\n• Q dòng tiếp theo, mỗi dòng gồm hai số nguyên a và b ( ) mô tả một truy vấn.\n\n## Output Specification\n\n• Với mỗi truy vấn, in ra một dòng gồm một số nguyên duy nhất là số đoạn thẳng ít nhất cần lựa chọn. Trong trường hợp không có cách chọn, hãy in ra -1.\n\n## Sample Input\n\n5\n1 4\n2 6\n3 5\n7 8\n9 10\n3\n1 3\n2 6\n6 10\n\n## Sample Output\n\nCase #1: 1\nCase #2: 2\nCase #3: -1",
    "group": 4,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "FSEGMENT - Truy vấn đoạn thẳng",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 265
},
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "PRESENT",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Một cửa hàng A ban đầu có M món hàng đánh số từ 1 đến M. Món hàng thứ i có giá tiền là i. Cửa hàng này có một điểm đặc biệt là không có hàng trong kho và cần mất một ngày để nhập hàng mới, tức là nếu một món hàng i được bán vào ngày hôm qua, thì đến tận ngày mai mới có thể bán tiếp món hàng giá tiền tương ứng.\n\nSau nhiều thời gian dành dụm, Anh đã để dành được N đồng vàng. Anh quyết định sẽ dùng N đồng vàng, mỗi ngày mua quà ở cửa hàng A tặng cho crush của mình. “Mưa dầm thấm lâu”, Anh muốn tặng quà cho crush nhiều ngày liên tục nhất có thể.\n\nTính số ngày liên tiếp mà Anh có thể mua quà cho crush mình.\n\n## Input Specification\n\nDữ liệu bao gồm nhiều bộ test:\n\nDòng đầu chứa một số nguyên T là số lượng test (1 ≤ T ≤ ).\nT dòng tiếp theo, mỗi dòng chứa 2 số nguyên M, N (1 ≤ M ≤ N ≤ ).\n\n## Output Specification\n\nGồm T dòng, mỗi dòng chứa số nguyên là số ngày liên tục nhiều nhất mà Anh có thể mua quà tặng cho crush ứng với mỗi test case.",
    "group": 4,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "PRESENT - Quà tặng crush",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 266
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "CORONA",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Dịch bệnh Covid-19 đã xuất hiện và lây lan mạnh trên phạm vi toàn cầu. Giả sử, tại vương quốc Anh, ngày (tính theo Dương lịch) là ngày xuất hiện ca đầu tiên; sang ngày thứ n tổng số ca mắc là F(n); ngày thứ n+1 tổng số ca mắc là F(n+1), ... và cứ thế, tổng số ca mắc ở quốc gia này cứ tăng liên tục theo quy luật đó.\n\nSiro tự hỏi:\n\nĐến ngày d, tháng m, năm y nào thì tổng số ca mắc ở vương quốc Anh đạt x ca?\nNếu tính hết đến ngày đó thì tổng số ca mắc là bao nhiêu?\nBạn là một lập trình viên tài ba của LuyenCode, bạn lập trình tính và giải đáp vấn đề trên giúp Siro nhé!\n\n## Input Specification\n\nDòng đầu tiên chứa số nguyên dương T là số lượng bộ test;\nDòng tiếp theo, ghi số nguyên dương x.\n\n## Output Specification\n\nVới mỗi bộ test, ghi theo định dạng sau:\n\nDòng đầu tiên là ngày d, tháng m, năm y theo định dạng d/m/yyyy;\nDòng thứ hai là tổng số ca mắc nếu tính hết ngày d, tháng m, năm y.",
    "group": 4,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "CORONA - Số ca mắc Covid-19",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 267
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "TEAWORLD",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Trong một lần đi ngao du sơn thủy, GS. X không may lạc vào vương quốc của những cửa hàng trà sữa. Vị giáo sư mặc dù rất thích uống trà sữa nhưng vẫn muốn tìm cách thoát ra khỏi đó còn tiếp tục đi quảng cáo kiếm tiền mua trà...\n\nCó thể coi vương quốc trà sữa thực sự là không gian 3D, để thoát ra khỏi vương quốc này, trước hết GS. X cần nạp năng lượng cho mình bằng việc ... uống trà sữa. Có N cửa hàng, cửa hàng trà sữa thứ i đặt tại điểm (Xi, Yi) và có thể bán lượng trà sữa tối đa là Ai.\n\nGS. X đang đứng tại điểm (Xg, Yg, Zg). Các cửa hàng trà sữa đều cung cấp loại ống hút dài vô tận, giúp GS. X có thể đứng từ vị trí hiện tại hút trà sữa từ mọi cửa hàng (hút hết lượng trà sữa của cửa hàng đó) mà không cần phải di chuyển. Tất nhiên, ống hút sẽ được đặt theo đoạn thẳng nối giữa vị trí của GS. X và quán trà sữa.\n\nTuy nhiên, việc hút trà sữa của GS không thực sự dễ dàng như vậy. Do đang là mùa giáng sinh nên các cửa hàng có treo các quả cầu giáng sinh ở khắp nơi. Theo quan sát của GS, có K quả cầu rỗng đang được treo, quả cầu thứ i có bán kính Ri và có tâm đặt tại (Xi, Yi, Zi). GS. X sẽ không thể hút trà sữa từ một quán nếu đoạn thẳng nối vị trí của GS tới quán đó bị chắn bởi ít nhất 1 quả cầu.\n\nVì muốn bán được nhiều trà sữa nên nhân viên các cửa hàng quyết định sẽ dọn đi K quả cầu. Bạn hãy tính lượng trà sữa lớn nhất GS. X có thể hút được từ vị trí của mình nếu đã dọn đi K quả cầu.\n\n## Input Specification\n\nDòng đầu tiên gồm 3 số nguyên: N, K, Q. Sau đó, các dòng tiếp theo mô tả K quả cầu: mỗi quả cầu có 4 số nguyên Xc, Yc, Zc, Rc (tọa độ tâm và bán kính quả cầu).\nDòng tiếp theo là mô tả các cửa hàng trà sữa: mỗi cửa hàng có 4 số nguyên Xs, Ys, As (tọa độ của cửa hàng và lượng trà sữa).\nCuối cùng, dòng thứ N+2 là tọa độ vị trí GS. X đang đứng.\n\n## Output Specification\n\nMột dòng duy nhất, ghi tổng lượng năng lượng lớn nhất có thể thu được.",
    "group": 4,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "TEAWORLD - Vương quốc trà sữa",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 268
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "COLORGRAPH",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Cho một cây gồm N đỉnh, mỗi đỉnh có một màu khác nhau. Gọi f(u, v) là số màu phân biệt trên đường đi từ đỉnh u tới đỉnh v. Đặt f(u) là giá trị f(u, v) với mọi đỉnh v bất kỳ. Hãy tính f(u) với mọi đỉnh u bất kỳ.\n\n## Input Specification\n\nDòng đầu tiên chứa số nguyên N.\n\nDòng thứ hai chứa N số nguyên, lần lượt là màu của các đỉnh.\n\nDòng tiếp theo, mỗi dòng chứa hai số nguyên u và v mô tả một cạnh của cây nối giữa hai đỉnh u và v. Dữ liệu vào đảm bảo đồ thị có dạng là cây.\n\n## Output Specification\n\nGồm N dòng, dòng thứ i chứa số nguyên f(i).",
    "group": 4,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "COLORGRAPH - MÀU TRÊN CÂY",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 269
}
,
{
  "fields": {
    "ac_rate": 0.0,
    "allowed_languages": [3, 4, 5, 6, 2, 7, 1, 8],
    "authors": [1],
    "banned_users": [],
    "code": "GAME2",
    "curators": [],
    "date": "2024-12-21T05:00:00Z",
    "description": "Trên mỗi một trong số N quân bài có ghi một số nguyên dương nhỏ hơn 1000. Các quân bài được xếp thành một dãy, quân nọ nối tiếp quân kia. Bờm vừa phát minh ra một trò chơi mới. Trò chơi đòi hỏi thực hiện một số bước. Tại mỗi bước phải loại bỏ một trong các quân bài trong dãy, không được phép loại quân bài đầu tiên cũng như quân bài cuối cùng. Đối với mỗi quân bài bị loại bỏ sẽ nhận được số điểm bằng tích của số ghi trên quân bài này với tổng các số ghi trên hai quân bài xếp cạnh nó. Trò chơi kết thúc khi dãy chỉ còn hai quân bài đầu tiên và cuối cùng.\n\nYêu cầu: Hãy tìm số lượng điểm lớn nhất có thể đạt được từ trò chơi mà Bờm vừa phát hành.\n\n## Input Specification\n\nDòng đầu tiên chứa số nguyên N.\nDòng tiếp theo chứa N số nguyên là các số viết trên các quân bài được liệt kê theo thứ tự chúng xuất hiện trên dãy quân bài.\n\n## Output Specification\n\nGhi ra một số nguyên là số lượng điểm lớn nhất tìm được.",
    "group": 4,
    "is_manually_managed": false,
    "is_public": true,
    "license": null,
    "memory_limit": 65536,
    "name": "GAME2 - Trò chơi của Bờm",
    "og_image": "",
    "partial": true,
    "points": 50.0,
    "short_circuit": false,
    "summary": "",
    "testers": [],
    "time_limit": 5.0,
    "types": [11, 16],
    "user_count": 0
  },
  "model": "judge.problem",
  "pk": 270
}
]
